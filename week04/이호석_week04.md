# 📌 8장 인덱스

인덱스는 DB 쿼리 성능 언급시 뺴놓을 수 없는 부분입니다.

전문 검색, 위치 기반 검색 기능은 MyISAM에서만 제공하던 기능인데 InnoDB 스토리지 엔진에서 사용할 수 있게 개선 됐습니다.

다만 옵티마이저가 발전 및 개선 되어도 여전히 관리자의 역할은 매우 중요합니다. 따라서 인덱스는 개발자 및 관리자에게 매우 중요한 부분이며 쿼리 튜닝의 기본이 될 것입니다.

<br><br><br>

## ✅ 8.1 디스크 읽기 방식

- `CPU`, `메모리`와 같은 전기적 특성을 띤 장치의 성능은 짧은 시간 매우 빠른 속도로 발전 했지만, 디스크 같은 기계식 장치 성능은 제한적으로 발전함
- 데이터 저장 매체인 디스크나 SSD같은 것들은 느린 발전 속도 때문에 컴퓨터에서 가장 느린 부분입니다.
- DB 성능 튜닝 == 어떻게 디스크 I/O를 줄이느냐가 관건

<br><br>

### 8.1.1 HDD와 SSD

DBMS에선 디스크 장치가 병목이 됨 (가장 느리기때문에)

이를 위해 SSD로 대체하는 추세 여전치 D-RAM보다는 느리지만 HDD보다는 빠르다

- 한 번에 많이 데이터를 읽는 순차 IO에선 ssd가 hdd보다 조금 빠르거나 비슷하다.
- 다만 ssd는 랜덤 io에서 훨씬 빠른 속도를 보장한다.
- dbms에서 순차 io보단 랜덤 io의 비중이 크므로 ssd가 dbms용 스토리지에 최적이라고 할 수 있다.

<br><br>

### 8.1.2 랜덤 io와 순차 io

- 데이터를 읽기 위해선 하드 디스크 드라이브의 플래터를 돌려서 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽습니다.
- 순차 io와 랜덤 io는 `N개`의 데이터를 읽어야 하는 상황에서 차이가 납니다.
    - 순차io는 N개의 읽을 데이터가 연속적으로 있기 때문에 디스크 헤더를 한번만 움직이고도 한번에 데이터를 읽을 수 있지만
    - 랜덤 io의 경우 헤더의 위치가 랜덤하게 N번 움직이고 데이터를 읽기 때문에 순차 io가 훨씬 빠르다고 볼 수 있습니다.

<br>

**결국 디스크의 성능은 디스크 헤더 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 결정됩니다.**

→ ssd는 디스크 원판이 없지만 랜덤io가 순차보다 전체 스루풋(`통신에서 네트워크 상의 어떤 노드나 터미널로부터 또 다른 터미널로 전달되는 단위 시간당 디지털 데이터 전송으로 처리하는 양`)이 떨어집니다.

<br>

**쿼리 튜닝 목적 → 랜덤 io를 줄이는것 → 쿼리 처리시 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미**

<br><br><br>

## ✅ 8.2 인덱스란?

인덱스는 책에 존재하는 색인, 책의 내용이 데이터 파일에 해당됨

DBMS가 DB 테이블의 모든 테이블을 읽어오는것은 시간이 오래 걸림 따라서 **칼럼의 값과 레코드가 저장된 주소를 key-value로 삼아 인덱스를 만들어 둡니다.**

책의 색인과 인덱스의 공통점은 또 정렬이 있습니다. 책의 찾아보기 내용이 많아진다면 가나다, abc순으로 정렬하는데 DBMS 인덱스도 빠르게 찾아갈 수 있게 칼럼의 값을 주어진 순서로 미리 정렬하여 보관합니다.

자료구조로 인덱스와 데이터 파일을 비교해 갈 수 있습니다.

- SortedList: DBMS 인덱스와 같음, 데이터가 삽입될때마다 항상 정렬된 상태를 유지함
    - 데이터 저장때마다 항상 정렬하므로 저장 과정이나 속도가 복잡, 느림 (insert, delete, update느림)
    - 정렬되어있으므로 빨리 원하는 값 찾아올 수 있음(select빠름)
- ArrayList: 데이터 파일과 같은, 데이터가 저장된 순서 그대로 유지함(정렬없이

**→ dbms에서 인덱스는 데이터의 저장 성능을 희생하고 대신 데이터의 읽기 속도를 높이는 기능임**

<br>

**역할별 인덱스 구분**

인덱스는 `primary key`, `secondary key`(보조키, 세컨더리 인덱스)로 구분할 수 있음

- `PK`: 테이블에서 레코드를 식별할 수 있는 기준값(식별자) null, 중복 허용 x
- `보조키`: PK를 제외한 나머지 모든 인덱스 다만 유니크 인덱스는 PK와 성격이 비슷하고 Pk를 대체할 수 있어 대체키라고도 하지만 그냥 세컨더리 인덱스로 분류하기도 함

<br>

**데이터 저장 방식(알고리즘)별 인덱스 구분**

인덱스 구현 알고리즘: 데이터 저장 방식(알고리즘)별로 구분할 경우 많은 분류가 되지만 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있음

- `B-Tree 알고리즘`
    - 가장 일반적 사용, 오래전 도입, 성숙해진 상태
    - 칼럼의 값을 변형없이 원래 값 그대로 이용해 인덱싱 함
    - mysql에선 위치 기반 검색 지원을 위한 r-tree 인덱스 알고리즘도 있지만 b-tree의 응용 알고리즘임
- `Hash 인덱스 알고리즘`
    - 칼럼의 값으로 해시값을 계산해 인덱싱하는 알고리즘
    - 매우 빠른 검색 지원(Hash값은 전부다르니까)
    - 값 변형이 있기 때문에 값은 prefix일치와 같이 값의 일부만 검색, 범위 검색 시에는 해시 인덱스 사용 불가능
    - 주로 메모리 기반 데이터베이스에서 사용됨

<br>

**데이터 중복 허용 여부별 인덱스 분류**

`unique`, `non-unique` 인덱스로 구분됨

유니크 여부의 구분을 단순하게 보면 같은 값의 중복 여부를 의미하지만

**DBMS 쿼리 실행 주체자인 옵티마이저에겐 상당히 중요한 문제가 됨 → 유니크 인덱스에 대해 동등 조건(=)로 검색한다는 건 항상 1건의 레코드만 찾게 된다는 사실을 옵티마이저에게 알려주는 효과를 줌**

<br>

**인덱스 기능별 분류**

전문 검색용 인덱스, 공간 검색용 인덱스 등을 예시로 들 수 있음

<br><br><br>

## ✅ 8.3 B-Tree 인덱스

B-Tree는 DB 인덱싱 알고리즘 가운데 가장 먼저 도입됐고 일반적으로 사용되며 아직도 범용적인 목적으로 사용된다.(전문 검색과 같은 특수 요건 아니면 일반적인 용도에 적함)

여러가지 변형 형태도 존재하는데 일반적으로 DBMS에선 B+-Tree혹은 B*-Tree가 사용됨

B의 의미는 Balanced로 균형잡힌 트리를 의미한다.

B-Tree는 칼럼의 값을 변형하지 않고 값의 앞부분만 잘라 관리하고 구조체 내에선 항상 정렬된 상태를 유지합니다.

<br><br>

### 8.3.1 구조 및 특성

B-Tree 인덱스의 구조는 3단계로 나뉨

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/ebbdcef1-ab9c-4339-b3fd-1fbc30470aee)


- 루트 노드 (트리의 최상위 노드)
- 브랜치 노드(루트도, 리프도 아닌 중간 노드)
    - 리프 노드(자식 노드가 없는 노드): 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가짐
- 인덱스의 키 값은 모두 정렬돼 있고, 데이터 파일 레코드는 정렬돼 있지 않음
    - 테이블의 레코드가 삭제되어 빈공간이 생기면 다음 insert는 해당공간에 삽입되므로 insert순서로 저장되지는 않는다.
- InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 PK 키 순서로 정렬되어 저장됨

인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 함

InnoDB 스토리지 엔진을 사용하는 테이블은 프라이머리 키가 ROWID역할을 합니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/42de8388-3629-4186-b42f-cb8232822d0d)


InnoDB 테이블

세컨더리 인덱스를 통해 데이터를 찾아가는데 InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있습니다.

따라서 레코드를 읽을때 데이터 파일을 바로 찾아가지 못하고 `클러스터링 인덱스`를 반드시 거쳐 갑니다.

**InnoDB 스토리지 엔진의 모든 세컨더리 인덱스는 검색에서 데이터 레코드를 읽기 위해서 반드시 PK를 저장하고 있는 B-Tree(클러스터링 인덱스)를 다시 한번 검색해야 합니다.**

→ 성능이 떨어질 것 같지만 장단점을 가짐

<br><br>

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

테이블의 레코드를 저장, 변경 하는 경우 인덱스 키 추가 및 삭제 작업이 발생함 → 이 과정을 알아두면 쿼리의 성능을 쉽게 예측할 수 있다.

<br>

**인덱스 키 추가**

새로운 키 값이 B-Tree에 저장될 때 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될수도 그렇지 않을수도 있다.

- B-Tree의 쓰기 작업이 비용이 많이 드는 이유
    1. 저장되는 키 값을 이용해 B-Tree에서 적절한 위치를 검색
    2. 저장될 위치 결정되면 B-Tree의 리프노드에 레코드의 키와 주소 정보를 저장함
    3. 리프노드가 꽉찼다면 분리해야 하는데, 상위 브랜치 노드까지 처리의 범위가 넓어짐

인덱스 추가로 인한 insert, update 문장의 영향을 확인하려면 테이블의 칼럼 수, 크기, 인덱스 칼럼 특성 등 다양한 요소를 파악해야 함

대략적으로는 다음과 같이 확인할 수 있음

- 테이블의 레코드를 추가하는 작업 비용이 1일때
- 인덱스에 키를 추가하는 작업 비용을 1.5 정도로 예측한다.

**→ 테이블의 인덱스가 3개라면 레코드 추가 비용 1 + 인덱스 추가 비용 1.5 * 3 = 5.5정도로 예측 됩니다.**

→ 위 예시는 메모리 CPU 처리 시간이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야하는 시간을 말합니다.

InnoDB 스토리지 엔진은 위 작업을 좀 더 지능적으로 처리합니다. 인덱스 키 추가 작업을 지연시킬 수 있습니다.(체인지 버퍼 사용)

하지만 PK나 Unique 인덱스의 경우 `중복 체크 문제`로 즉시 B-Tree에 추가 및 삭제를 합니다.

<br>

**인덱스 키 삭제**

- 키 값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크만 하여 작업을 완료 시킴
- 삭제 마킹된 인덱스 키 공간은 방치하거나 재활용됩니다.
- 마킹 작업은 디스크 IO가 필요한 작업(5.5 이상부터의 InnoDB 스토리지 엔진은 버퍼링을 통한 지연처리)

<br>

**인덱스 키 변경**

- 인덱스의 키 값은 값에 따라 저장될 위치가 결정됩니다. → 정렬을 하므로
- 따라서 단순히 변경하는 작업은 할 수 없고 `삭제 → 추가`의 과정을 통해 키 변경 작업을 진행합니다.
    - InnoDB 스토리지 엔진을 사용하는 테이블에 대해선 체인지 버퍼를 활용해 지연 처리가 가능합니다.

<br>

**인덱스 키 검색**

- INSERT, UPDATE, DELETE 작업을 할 때 추가 비용을 감당하며 인덱스를 구축하는 이유가 검색을 위함입니다.
- 검색은 루트 노드 → 브랜치 노드 → 리프 노드로 이동하는 인덱스 트리 탐색 작업을 합니다. 이는 SELECT 뿐만 아니라 UPDATE, DELETE를 처리하기 위해 레코드를 검색할 필요가 있는 경우에도 사용됩니다.
- 다음과 같은 경우에 인덱스를 이용한 검색을 사용하거나 혹은 사용할 수 없음
    - 100% 일치하는 값 또는 값의 앞 부분(Left-most-part)만 일치하는 경우 사용 가능
    - 부등호(<, >) 비교조건 사용 가능
    - 키 값의 뒷부분만 검색하는 용도로는 사용 불가능
    - 키 값에 변형이 가해진 후 비교되는 경우 사용 불가능
        
        함수나, 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 키 값에 변형을 줌, B-Tree의 장점 이용 불가
        
<br><br>

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

칼럼의 크기, 레코드의 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색, 변경 작업의 성능이 영향을 받습니다.

<br>

**인덱스 키 값의 크기**

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 합니다.

- 페이지
    - 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위
    - InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위
    - 인덱스도 페이지 단위로 관리됨 (루트, 브랜치, 리프 노드를 구분한 기준이 페이지 단위)
    
- DBMS B-Tree는 자식 노드의 개수가 가변적인 구조
    - 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드의 숫자가 결정됨
    - 페이지 사이즈 16KB, 인덱스 키 16byte, 자식 노드 12byte
        - 2^14 / 28 = 585개의 키 저장 가능
    - 페이지 사이즈 16KB, 인덱스 키 32byte, 자식 노드 12byte
        - 2^14 / 44 = 372개의 키 저장 가능
    

SELECT 쿼리가 레코드 500개를 읽어야 하는 상황에서 전자의 경우 인덱스 페이지 한번으로 해결되지만, 후자의 경우 2번 이상 디스크 IO가 발생함

즉, 인덱스 구성 키 값의 크기가 커진다는 것은 디스크로부터 읽어와야 하는 횟수가 늘어나 느려지고, 전체적인 인덱스의 크기가 커진다는것을 의미합니다.

결국 InnoDB 버퍼 풀이나 MyISAM의 키 캐시 영역과 같은 제한적인 크기에서 캐시할 수 있는 레코드의 수가 줄어들고 메모리 효율도 낮아지는 결과를 가져올 수 있습니다.

<br>

**B-Tree 깊이**

B-Tree 인덱스의 깊이는 중요하지만 제어할 수 있는 방법은 없습니다.

- 깊이가 최대 3인 B-Tree일때
    - 페이지 사이즈 16KB, 인덱스 키 16byte, 자식 노드 12byte → `585^3` → `2억개 정도의 키 담음`
    - 페이지 사이즈 16KB, 인덱스 키 32byte, 자식 노드 12byte → `372^3` → `5천만개 정도의 키 담음`

결국 키 값이 커질수록 하나의 페이지에 담을 수 있는 키 값의 개수가 적어지므로 디스크 IO가 더 많이 필요합니다. **따라서 인덱스 키 값의 크기는 가능하면 작게 만드는 것이 좋습니다.**

<br>

**선택도(기수성, Cardinality)**

인덱스에서 선택도, 기수성은 거의 같은 의미 사용됩니다. 

**기수성은 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미합니다. 
(100개의 인덱스 키 중에서 유니크한개 10개라면 기수성은 10)**

따라서 기수성(선택도)가 높을수록 검색 대상이 줄어들기에 빠르게 처리됩니다.

인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미칩니다.

```sql
# 1만건의 레코드가 있을때
CREATE TABLE tb_city (
	country VARCHAR(10),
	city VARCHAR(10),
	INDEX ix_country (country)
);

SELECT * FROM tb_test WHERE country='KOREA' AND city='SEOUL';
```

- country 칼럼의 유니크 값이 10개일때
    
    country=’KOREA’ 조건으로 인덱스를 검색하면 약 `1000`건(10000/10)이 일치할것이 예측됩니다.
    뒤의 SEOUL인 것을 제외하면 결국 `999개의 레코드는 불필요`해집니다.
    
- country 칼럼의 유니크 값이 1000개일때
    
    country=’KOREA’ 조건으로 인덱스를 검색하면 약 `10`건(10000/1000)이 일치할것이 예측됩니다.
    뒤의 SEOUL인 것을 제외하면 결국 `9개의 레코드는 불필요`해집니다.
    

똑같은 실행결과를 받더라도 두 쿼리가 처리되기 위해 MySQL 서버가 수행한 작업 내용은 매우 큼을 알 수 있습니다.

<br>

**읽어야 하는 레코드의 건수**

인덱스를 통해 테이블의 레코드를 읽는것은 인덱스를 거치지 않고 테이블의 레코드를 읽는 것보다 약 4~5배정도 높은 비용을 갖습니다.

**읽어야 할 레코드 건수(옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어 필요한 레코드만 가려내는 방식으로 처리합니다.**

<br><br>

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

어떤 경우에 인덱스를 사용하게 유도할지 말지를 판단하려면 실제 레코드를 읽어 내는 방식을 알아야 합니다.
(대표적으로 3가지의 방식이 존재함)

<br>

**인덱스 레인지 스캔(타이트 인덱스 스캔)**

인덱스의 접근 방법 가운데 가장 대표적인 방식, 다른 방식보다 빠른 방법입니다.
(레코드를 한 건 혹은 한 건 이상 읽는 경우를 다르게 구분하지만 여기서는 묶어서 표현)

```sql
SELECT * from employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/4e9454ab-a46a-4328-b242-4dd8b1eae571)

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/6673c009-d04d-4d5e-8511-f01e49d2d2c8)


- 인덱스의 범위가 결정 됐을때 사용하는 방식
- 검색하려는 값의 수, 결과 레코드 수와 관계없이 레인지 스캔이라고 표현합니다.
- 위의 좌측 그림처럼 루트 → 브랜치 → 리프 노드까지 들어가 레코드의 시작 지점을 찾고 쭉 스캔합니다.
- 다만 우측 그림처럼 실제 데이터 파일의 레코드를 읽어오는 과정도 필요합니다.
    - 랜덤 I/O의 발생이므로 인덱스를 통해 읽을 데이터가 전체의 20~25%를 넘으면 비용이 많이 드는 작업으로 분류됨
- 인덱스 자체가 정렬되어 있기 때문에 스캔 위치(오름, 내림차순)에 관계 없이 항상 정렬된 상태로 레코드를 가져옵니다.

결국 인덱스 레인지 스캔은 `3단계`를 거칩니다.

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾음 (인덱스 탐색: index seek)
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽음 (인덱스 스캔: index scan) → 1, 2번 모두를 인덱스 스캔이라고도 함
3. 2번에서 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어옵니다.
    
    →  커버링 인덱스는  3번과정이 필요하지 않은데 디스크의 레코드를 읽지 않아도 되므로 랜덤 읽기가 줄어들고 성능은 빨라집니다.
    

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/65d5e294-63e2-4d38-abc9-33bf8c766e85)


1번과 2번 단계의 작업 수행을 확인할 수 있는 상태값들

`Handler_read_key`: 1번 단계가 실행된 횟수

`Handler_read_next`, `_prev`: 2번 단계로 읽은 레코드 건수 
(각각 인덱스 정순, 역순으로 읽은 건수)

`Handler_read_first`, `_last`: 인덱스의 첫번째 레코드와 마지막 레코드를 읽은 횟수를 의미
(MIN(), MAX()와 같은 값을 읽는 경우 증가하는 상태값)

→ 실제 인덱스만 읽었는지 인덱스를 통해 테이블의 레코드를 읽었는지(3번단계)는 구분하지 않습니다.

<br>

**인덱스 풀 스캔(타이트 인덱스 스캔)**

- 인덱스의 처음부터 끝까지 모두 읽는 방식을 말함
- 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용됩니다.
(인덱스가 (A, B, C)순서 일때 B, C를 조건절로 검색하는 경우)
- 직접 테이블을 처음부터 끝까지 읽는것보다 인덱스만 읽는 것이 효율적임
- 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있다면 주로 사용됨
(데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리되지 않음)

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/ab6c1f2a-099e-4860-8ed6-d774937a00c9)


- 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔 보다는 효율적이다. 
(인덱스 칼럼만으로 처리하면 굳이 테이블의 레코드를 읽지 않아도 되기 때문)
- 테이블 풀 스캔보다 훨씬 적은 디스크 I/O로 쿼리를 처리함

<br>

**루스 인덱스 스캔**

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/4f506c8f-6d59-4aca-85a0-921e24ffb55c)


```sql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```

- dept_no, emp_no라는 두 개의 칼럼으로 인덱스가 생성돼 있을 경우, 해당 인덱스는 (dept_no, emp_no) 조합으로 오름차순 정렬까지 되어 있습니다.
- 따라서 dept_no 그룹별로 첫번째 레코드의 emp_no값만 읽으면 됩니다.
- 옵티마이저는 이런 사실을 알고 있으므로 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동하게 됩니다.

<br>

**인덱스 스킵 스캔**

```sql
# 2개의 칼럼으로 인덱스를 생성함
ALTER TABLE employees ADD INDEX ix_gender_birthdate (gender, birth_date);

# MySQL 8.0부터는 인덱스의 하나의 칼럼을 건너뛰어도 가능한 인덱스 스킵 스캔을 지원함
SELECT * FROM employees WHERE birth_date>='1965_02_01';
SELECT * FROM employees WHERE gender='M' AND birth_date>='1965_02_01';
```

- 루스 인덱스 스캔은 GROUP BY 작업을 처리하기 위해 인덱스를 사용하지만, 8.0부터의 인덱스 스킵 스캔은 WHERE 조건절의 검색을 위해 사용 가능하도록 용도가 좀 더 넓습니다.

- 인덱스 스킵 스캔을 비활성화 하면 - `full index scan`
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/858333a4-2a53-4fbd-b9e3-e7afae85f86b)

    
    - type이 index라면 풀 인덱스 스캔을 의미
    - gender, birth_date는 인덱스에 포함되는 칼럼이므로 ix_gender_birthdate 인덱스를 풀스캔
- 인덱스 스킵 스캔을 활성화 하면 - `index skip scan`
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/6cc21382-3e05-4349-b904-91af3d9a3d12)

    
    - type이 range라면 인덱스에서 꼭 필요한 부분만 읽음을 의미
    - Using index for skip scan은 인덱스 스킵 스캔을 활용해 데이터를 조회함을 의미함

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/0b755001-bb97-4864-8661-72bc66c32e9b)


위 그림과 같이 MySQL 옵티마이저는 gender 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 칼럼의 조건을 추가해 쿼리를 다시 실행하는 형태로 처리합니다.

```sql
# gender 칼럼은 성별을 구분하는 컬럼으로 M, F의 값만 가지는 ENUM타입 칼럼, 따라서 옵티마이저는 아래와 같은 2개의 쿼리를 실행함
SELECT gender, birth_date FROM empolyees WHERE gender='M' AND birth_date>='1965-02-01';
SELECT gender, birth_date FROM empolyees WHERE gender='F' AND birth_date>='1965-02-01';
```

→ MySQL 서버는 인덱스를 루스 인덱스 스캔과 동일한 방식으로 읽으면서 인덱스에 존재하는 모든 값을 먼저 도출하고 그 결과를 이용해 인덱스 스킵 스캔을 실행함

위와 같은 특성 때문에 인덱스 스킵 스캔을 사용하기 위한 조건(혹은 단점)도 있습니다.

- WHERE 조건절에 명시되지 않은 인덱스 칼럼의 경우 칼럼 자체의 유니크한 값의 개수가 적어야 합니다.
    - 유니크 값이 너무 많아지면 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많아져 쿼리의 처리 성능이 오히려 느려질 수 있습니다.
- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/7ea43d48-8ea3-401d-b525-2b5156e13932)

    

**→ 인덱스 스킵 스캔은 인덱스의 선행 칼럼이 가진 유니크한 값의 개수가 소량일 때만 적용 가능한 최적화 입니다.**

<br><br>

### 8.3.5 다중 칼럼(Mulit-column)인덱스

실제 서비스용 데이터베이스에선 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용됩니다.

두 개 이상 칼럼으로 구성된 인덱스를 말하며, `Concatenated Index` 라고도 합니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/4a3b1478-91b7-4629-a86a-29e06b1c03bc)


- 인덱스의 두번째 칼럼은 첫번째 칼럼에 의존해서 정렬돼 있습니다.
    - 첫번째 칼럼이 같아야 두번째 칼럼의 정렬이 의미가 있음
- 따라서 다중 칼럼 인덱스에서 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하며, 신중히 결정해야 합니다.

<br><br>

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

인덱스를 생성할 때 설정한 정렬 규칙에 따라서 인덱스의 키 값은 항상 오름차순 혹은 내림차순으로 정렬되어 저장됩니다.

다만 특정 방향으로 정렬되었지만, 반대방향으로도 읽을 수 있습니다. 어떤 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 실행계획을 만들어 결정됩니다.

<br>

**인덱스의 정렬**

8.0 버전부터는 아래와 같은 정렬 순서를 혼합한 인덱스를 생성할 수 있게 됨

```sql
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```

<br>

**인덱스 스캔 방향**

```sql
SELECT * FROM employees ORDER BY first_name DESC LIMIT 1;
```

인덱스는 항상 오름순으로만 정렬돼 있지만 인덱스를 최솟값부터 읽으면 오름차순으로 값을 가져올 수 있고, 최댓값 부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 MySQL 옵티마이저가 이미 알고 있습니다.

따라서 위의 쿼리는 인덱스를 역순으로 접근해 첫 번째 레코드만 읽게 됩니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/0b861570-55dd-4954-a54a-38913292f353)


→ 인덱스 생성 시점에 ASC, DESC가 결정되지만 쿼리가 인덱스를 사용하는 시점에는 인덱스를 읽는 방향에 따라 오름차순 혹은 내림차순 정렬 효과를 얻습니다.

```sql
SELECT * FROM employees WHERE first_name>='Anneke' ORDER BY first_name ASC LIMIT 4;

SELECT * FROM employees ORDER BY first_name DESC LIMIT 5;
```

위 쿼리 모두 정순으로 읽거나, 역순으로 읽어서 처음 읽는 레코드들을 반환하면 되므로 인덱스 자체의 정렬 방향에 대응하여 읽기만 하면 됩니다.

쿼리의 ORDER BY, MIN(), MAX()와 같은 최적화가 필요한 경우도 MySQL 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어 냅니다.

<br>

**내림차순 인덱스**

first_name이라는 칼럼을 역순으로 정렬하는 요건만 있다면, 다음 2개의 인덱스는 성능의 차이를 보입니다.

```sql
CREATE INDEX ix_firstname_asc ON employees (first_name ASC);
CREATE INDEX ix_firstname_desc ON employees (first_name DESC);
```

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/de2ba54f-c865-4855-b6f0-97ab48650c99)


- `Ascending index` : 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
- `Descending index` : 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
- `Forward index scan` (Forward scan) : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
- `Backward index scan` (Backward scan) : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔

책의 예제를 보면 정순으로 정렬된 인덱스를 정순, 역순으로 스캔했을때의 실행결과에서 역순이 약 28.9%의 시간이 더 걸림을 알 수 있습니다.

**InnoDB에서 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느릴 수 밖에 없는 두 가지 이유는 다음과 같습니다.**

1. **페이지 잠금이 인덱스 정순 스캔에 적합한 구조**
2. **페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조**
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/abd524eb-2cb1-4d94-a6eb-34db22ba6ffe)

    
    - InnoDB 페이지는 힙(Heap)처럼 사용되므로 물리적으로 저장이 순서대로 배치되진 않음
    - 프라이머리 인덱스에서 리프 노드의 데이터는 실제 **레코드의 칼럼 값**
    - 세컨더리 인덱스 페이지에서 리프 노드의 데이터는 **프라이머리 키 값**

역순으로 조회하는 쿼리를 사용할때 쿼리가 많은 레코드를 조회하며 번번하게 실행되는 경우라면 오름차순 인덱스 보다는 내림차순 인덱스를 사용해볼것을 고려해볼 수 있습니다.

또한 많은 쿼리가 인덱스의 앞쪽, 뒤쪽만 집중적으로 읽어 특정 페이지 잠금의 병목이 될것이 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는데 도움이 될 것입니다.

<br><br>

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

쿼리의 WHERE, GROUP BY, ORDER BY절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 합니다.

<br>

**비교 조건의 종류와 효율성**

```sql
# 아래 쿼리에 대해
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no >= 10114;

# 다음과 같이 인덱스를 생성했을때
# CASE A: INDEX(dept_no, emp_no)
# CASE B: INDEX(emp_no, dept_no)
```

- A의 경우(효율적임)
    
    먼저 dept_no가 2인것부터 emp_no ≥ 10114인 지점을 찾는다면 dept_no가 d002가 아닐떄까지 쭉 읽으면 됩니다. (검색되는 레코드 모두 찾는 레코드와 일치)
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/2e8c02a7-40b5-44e7-a40e-f6d1924557ab)

    
- B의 경우(비효율적임)
    
    먼저 emp_no ≥ 10114인 지점을 찾고 dept_no가 d002인 레코드를 찾습니다.
    
    이때 emp_no ≥ 10114이지만 dept_no가 d002가 아닌 레코드도 검색되므로 A보다 효율이 떨어집니다.
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/4dc42adc-3ac5-4c96-a829-a26bc05835c9)

    

다중 칼럼 인덱스의 경우 정렬 방식은 인덱스의 N번째 키 값은 N-1 번째 키 값에 대해서 다시 정렬되기 때문에 위와 같은 차이가 발생합니다.

- 케이스 A인덱스에서의 두 조건과 같이 작업의 범위를 결정할 수 있는 조건을 `작업 범위 결정 조건`이라 말합니다.
- 반면에 B인덱스에서 `dept_no=’d002’`와 같이단순히 거름종이의 역할만 하는 조건을 필터링 조건(체크조건)이라고 말합니다.
    - 체크 조건이 많다고 성능이 좋아지진 않고 오히려 더 느린 쿼리 실행 결과를 만드는 경우가 있습니다.

<br>

**인덱스의 가용성**

B-Tree인덱스의 특징은 왼쪽 값에 기준해서(Left-most)오른쪽 값이 정렬돼 있다는 것입니다.

이는 하나의 칼럼 뿐만 아니라 다중 칼럼 인덱스의 각 칼럼에 대해서도 함께 적용됩니다.

```sql
# 인덱스 INDEX(first_name)
# 인덱스 레인지 스캔 방식으로 인덱스 이용 불가
SELECT * FROM employees WHERE first_name LIKE '%mer';
```

→ 왼쪽부터 한글자씩 비교해 가며 일치해가는 레코드를 찾을 수 없으므 인덱스 레인지 스캔 방식으로 이용 불가

```sql
# 인덱스 INDEX(dept_emp, emp_no)
# 인덱스를 효율적으로 사용할 수 없음
SELECT * FROM dept_emp WHERE emp_no>=10114;
```

→ 인덱스의 선행 칼럼인 dept_emp 조건이 없으므로 모든 dept_emp에 대해서 조회해야 합니다. 따라서 인덱스를 효율적으로 사용할 수 없습니다.

<br>

**가용성과 효율성 판단**

B-Tree의 특성상 인덱스를 효율적으로 사용할 수 없는 조건들이 존재합니다. 
(경우에 따라서 체크 조건으로는 인덱스를 사용할 수 있다.)

- `NOT-EQUAL`로 비교된 경우 (NOT IN, NOT BETWEEN, IS NOT NULL)
    - WHERE column <> 'N'
    - WHERE column NOT IN (10,11,12)
    - WHERE column IS NOT NULL
- `LIKE %xxx` 형태 문자열 패턴 비교인 경우
    - WHERE column LIKE '%test‘
    - WHERE column LIKE '%test%‘
    - WHERE column LIKE '_test‘
- `스토어드 함수`나 다른 연산자로 `인덱스 컬럼이 변형된 후 비교`된 경우
    - WHERE SUBSTRING(column,1, 1) = 'X'
    - WHERE DAYOFMONTH(column) = 1
- 인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우
    - WHERE char_column = 10 → char를 int와 비교
- 문자열 데이터 타입의 콜레이션이 다른 경우
    - WHERE utf8_bin_char_column = euckr_bin_char_column

→ 추가로 MySQL에선 null값도 인덱스에 저장되는데 `WHERE column IS NULL`과 같이 작업 범위 결정 조건으로 인덱스를 사용할 수 있다.

- 예시
    
    ```sql
    INDEX ix_test (c1, c2, c3, ... , cn)
    ```
    
    - 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
        - c1 칼럼에 대한 조건이 없는 경우
        - c1 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
    - 작업 범위 결정 조건으로 인덱스를 사용하는 경우
        - c1 ~ ci-1 칼럼까지 동등 비교 형태(”=” 또는 “IN”)로 비교
        - ci 칼럼에 대해 다음 연산자 중 하나로 비교
            - 동등 비교(”=”, IN)
            - 크다 작다 형태
            - LIKE로 좌측 일치 패턴

<br><br><br>

## ✅ 8.4 R-Tree 인덱스

MySQL의 공간 인덱스는 R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스 입니다. 

주로 GPS나 지도 서비스를 내장하고 있는 스파트 폰이 대중화 되며 GIS, GPS 기반을 둔 서비스에서 위치 기반 서비스를 구현할때 사용됩니다.

MySQL의 공간 확장은 크게 3가지 기능이 포함돼 있습니다.

1. 공간 데이터를 저장할 수 있는 데이터 타입
2. 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
3. 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

<br><br>

### 8.4.1 구조 및 특성

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/2faa1724-2d8e-45a0-b012-4582f262fb84)


MySQL은 공간 정보의 저장 및 검색을 위해 위와 도형(Geometry)정보를 관리할 수 있는 데이터 타입을 제공합니다. (Geometry타입은 나머지 3개의 슈퍼 타입)

R-Tree 알고리즘을 이해하려면 MBR(Minimum Bounding Rectangle)의 약자로 해당 도형을 감싸는 최소 크기의 사각형을 의미 합니다. 이런 사각형의 포함 관계를 R-Tree로 구현한 인덱스가 R-Tree인덱스가 됩니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/b93ce435-45d9-4730-a4ab-caea934e5d75)


아래 도형들을 3개의 레벨로 나눠서 그리게 되면

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/8ba5d500-c5e4-471f-9138-ef776ab225e9)


아래와 같이 구분할 수 있습니다.

- 최상위 레벨: R1, R2 (R-Tree루트 노드에 저장)
- 차상위 레벨: R3, R4, R5, R6 (R-Tree 브랜치 노드에 저장)
- 최하위 레벨: R7 ~ R14 (R-Tree 리프 노드에 저장)

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/6cc7ef74-a69c-4163-b20a-8e58856df589)


![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/f726eedc-3e9d-4493-9ef9-2f6d64a20233)

<br><br>

### 8.4.2 R-Tree 인덱스의 용도

WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용됩니다. 하지만 위도, 경도 좌표뿐 아니라 CAD/CAM 소프트웨어 또는 회로 디자인 등과 같이 좌표 시스템에 기반을 둔 정보에 대해서는 모두 적용할 수 있습니다.

자세한 예시는 `256~258page 참조`

<br><br><br>

## ✅ 8.5 전문 검색(Full Text Search) 인덱스

MySQL B-Tree의 인덱스는 실제 칼럼의 값이 1MB이더라도 1,000바이트MyISAM) 또는 3,072바이트(InnoDB) 까지만 잘라서 인덱스 키로 사용합니다. 이후 전체 일치 또는 좌측 일부 일치와 같은 검색만 가능합니다.

문서 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문(Full Text) 검색에는 InnoDB나 MyISAM 스토리지 엔진에서 제공하는 일반적인 용도의 B-Tree 인덱스를 사용할 수 없습니다.

이런 상황에서 문서 전체에 대한 분석, 검색을 위한 인덱싱 알고리즘을 전문 검색 인덱스라고 합니다.

<br><br>

### 8.5.1 인덱스 알고리즘

문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석하고, 빠른 검색용으로 사용할 수 있게 키워드로 인덱스를 구축합니다.

크게 단어의 어근 분석과 n-gram 분석 알고리즘으로 구분할 수 있습니다.

<br>

**어근 분석 알고리즘**

크게 두 가지 과정을 거쳐 색인 작업이 수행됩니다.

- 불용어(stop word) 처리
    - 별 가치가 없는 단어를 필터링해 제거하는 작업
    - 상수로 정의해서 사용하는 경우가 많고, 사용자가 추가 및 삭제할 수 있음
- 어근 분석(Stemming)
    - 선정된 단어의 뿌리인 원형을 찾는 작업
    - 한굴 및 일본어는 어근 분석 보다는 문장의 형태소를 분석해 명사 및 조사를 구분하는 기능이 더 중요한 편

<br>

**n-gram 알고리즘**

전문적인 검색 엔진을 고려하는게 아니라면 n-gram 알고리즘을 고려해볼만 합니다.

n-gram은 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘이라고 할 수 있는데 본문을 무조건 몇 글자씩 잘라서 인덱싱 하는 방법 입니다.

n은 인덱싱할 키워드의 최소 글자 수를 의미하는데, 일반적으로는 2글자 단위로 키워드를 쪼개서 인덱싱하는 2-gram(or Bi-gram)방식이 많이 사용됩니다.

다음과 같은 문자의 토큰이 있을때

```
To be or not to be. That is the question
```

다음과 같이 bi-gram 토큰으로 쪼개질 수 있습니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/23fa068b-d597-4a78-b1ef-481a51513857)


위와 같이 구분된 토큰을 인덱스에 저장하기만 하면 됩니다. 중복된 토큰은 하나의 인덱스 엔트리로 병합되어 저장됩니다.

<br><br>

### 8.5.2 전문 검색 인덱스의 가용성

전문 검색 인덱스를 사용하려면 반드시 다음 두 가지 조건을 갖춰야 합니다.

- 쿼리 문장이 전문 검색을 위한 문법(MATCH… AGAINST…)을 사용
- 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

```sql
# 다음과 같이 전문 검색 인덱스 생성 했을때
CREATE TABLE tb_test (
		doc_Id INT,
		doc_body TEXT,
		PRIMARY KEY (doc_id),
		FULLTEXT KEY fx_docbody (doc_body) WITH PARSER ngram
) ENGINE=InnoDB;

# 다음 쿼리는 풀 테이블 스캔으로 처리함
SELECT * FROM tb_test WHERE doc_body LIKE '%애플%';

# 다음 쿼리는 전문 검색 인덱스를 사용함
SELECT * FROM tb_test WHERE MATCH(doc_body) AGAINST('애플'IN BOOLEAN MODE);
```

<br><br><br>

## ✅ 8.6 함수 기반 인덱스

칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축하려면 8.0버전 부터 지원해주는 함수 기반의 인덱스를 활용하면 됩니다.

함수 기반 인덱스는 두 가지로 구현하는 방법이 구분됩니다.

- 가상 칼럼을 이용한 인덱스
- 함수를 이용한 인덱스

함수 기반 인덱스는 인덱싱할 값을 계산하는 과정의 차이만 있을 뿐, 실제 인덱스의 내부적인 구조 및 유지관리 방법은 B-Tree 인덱스와 동일합니다.

<br><br>

### 8.6.1 가상 칼럼을 이용한 인덱스

```sql
CREATE TABLE user (
		user_id BIGINT,
		first_name VARCHAR(10),
		last_name VARCHAR(10),
		PRIMARY_KEY (user_id)
);
```

first_name과 last_name을 합쳐서 검색해야 할때 full_name인덱스를 추가하려면 다음과 같이 할 수 있습니다.

```sql
ALTER TABLE user
	ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
	ADD INDEX ix_fullname (full_name);
```

ix_full_name인덱스를 이용해 실행 계획이 만들어짐을 확인할 수 있다. 

가상 칼럼이 VIRTUAL이나 STORED 옵션 중 어떤 옵션으로 생성됐든 관계없이 테이블에 새로운 칼럼을 추가하는 것과 같은 효과를 내기에 테이블의 구조가 변경된다는 단점이 있습니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/250ecc1e-be8a-42a0-8e33-29d7cbac0cce)

<br><br>

### 8.6.2 함수를 이용한 인덱스

가상 칼럼은 5.7에서 사용할 수 있지만 MySQL 8.0 버전부터는 다음과 같이 테이블의 구조를 변경하지 않고 직접 사용하는 인덱스를 생성할 수 있습니다.

```sql
CREATE TABLE user (
		user_id BIGINT,
		first_name VARCHAR(10),
		last_name VARCHAR(10),
		PRIMARY_KEY (user_id),
		INDEX ix_fullname ((CONCAT(first_name, ' ', last_name))
);
```

함수 기반 인덱스를 제대로 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 합니다.

함수 생성 시 명시된 표현식과 쿼리의 WHERE 조건절에 사용된 표현식이 다르다면(설령 결과는 같다고 하더라도) MySQL 옵티마이저는 다른 표현식으로 간주해서 함수 기반 인덱스를 사용하지 못합니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/e858b830-e7e4-4b5b-8337-ddf1b2503661)


CONCAT 함수에 사용된 공백 문자 리터럴의 인코딩을 통일시켜주지 않으면 제대로 작동하지 않을 수 있음 (268page 참조)

<br><br><br>

## ✅ 8.7 멀티 밸류 인덱스

전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가집니다.

하지만 멀티 밸류 인덱스는 하나의 데이터 레코드가 여러개의 키 값을 가질 수 있는 `1:N` 형태의 인덱스 입니다.

정규화에 위배되는 형태긴 하지만 RDBMS들이 데이터 타입을 지원하기 시작하면서 JSON의 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생했기에 8.0부터 추가 되었습니다.

```sql
// 멀티 밸류 인덱스 생성
CREATE TABLE user (
    user_id BIGINT AUTO_INCREMENT PRIMARY KEY, 
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    credit_info JSON,
    INDEX mx_creditscores (
        (CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY))
    )
);

// INSERT
INSERT INTO user VALUES (1, 'Matt', 'Lee1', '{"credit.scores":[360, 353, 351]}');
```

멀티 밸류 인덱스를 활용하기 위해선 반드시 다음 함수들을 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립합니다.

- MEMBER OF()
- JSON_CONTAINS()
- JSON_OVERLAPS()

```sql
SELECT * FROM user WHERE 360 MEMBER OF(credit.info->'$.credit_scores');

+----------+------------+----------+--------------------------------------+
| user_id  | first_name |last_name | credit_info                          |
+----------+------------+----------+--------------------------------------+
|       1  | Matt       | Lee      | {"credit_scores": [360, 353, 351]}   |
+----------+------------+----------+--------------------------------------+
```

<br><br><br>

## ✅ 8.8 클러스터링 인덱스

MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 묶어서 저장하는 형태로 구현됨

주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것입니다. (InnoDB에서만 지원됨)

<br><br>

### 8.8.1 클러스터링 인덱스

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/094662a9-470e-4caf-a9ee-bd85051cfa2d)


- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정됨
- 프라이머리 키 값이 변경된다면 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미함
    - 프라이머리 키 값으로 클러스터링된 테이블은 PK 값 자체에 대한 의존도가 크므로 신중하게 PK를 결정해야 함

→ PK값에 의해 레코드의 저장 위치가 결정되므로 인덱스 알고리즘 이라기 보다는 테이블 레코드의 저장 방식이라고 볼 수 있습니다. (따라서 클러스터링 테이블과 클러스터링 인덱스는 동의어로 사용됨)

→ InnoDb와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 PK 기반 검색이 매우 빠르지만, 저장 및 변경이 상대적으로 느립니다.

→ 일반적인 B-Tree도 키 값으로 정렬되어 저장되지만 클러스터링 인덱스는 테이블의 레코드가 PK값으로 정렬되어 저장됩니다.

<br>

**PK가 없는 경우**

PK가  없다면 InnoDB 스토리지 엔진은 다음 우선순위대로 PK를 대체할 칼럼을 선택합니다.

1. PK가 있으면 기본적으로 PK를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택

3번의 겨웅 내부적으로 생성되는 것이므로 사용자에게 노출되지 않고, 어떤 혜택도 주지 않기 때문에 가능하면 PK를 명시적으로 생성해야 합니다.

<br><br>

### 8.8.2 세컨더리 인덱스에 미치는 영향

- MyISAM, MEMORY 테이블은 프라이머리 키나 세컨더리 인덱스의 각 키는 그 주소(ROWID)를 이용해 실제 데이터 레코드를 찾아옵니다
- InnoDB에선 위와 같이 인덱스가 실제 레코드의 주소를 갖는다면 키 값이 변경될때마다 데이터 레코드의 주소가 변경되고 해당 테이블의 모든 인덱스에 변경을 요구합니다.
- 따라서 InnoDB 테이블(클러스터링 테이블)의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어 있습니다.

<br><br>

### 8.8.3 클러스터링 인덱스의 장점과 단점

- 장점
    - PK로 검색할때 처리 성능이 매우 빠름 (특히 PK 범위를 겁색하는 경우 매우 빠름)
    - 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(커버링 인덱스)
- 단점
    - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
    - 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능 느림
    - INSERT할 때 프라이머리 키에 의해 레코드의 저장위치가 결정되기 때문에 처리 성능이 느림
    - PK를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림

→ 장점은 SELECT, 단점은 INSERT UPDATE DELETE라는걸 알 수 있음

<br><br>

### 8.8.4 클러스터링 테이블 사용 시 주의사항

**클러스터링 인덱스 키의 크기**

- 모든 세컨더리 인덱스가 PK값을 포함하므로 PK크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커집니다.
- 인덱스가 커질수록 같은 성능을 내기 위해 그만큼의 메모리가 필요해지므로 InnoDB 테이블의 PK는 신중하게 선택해야 합니다.

<br>

**프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성(가능한 경우)**

- PK는 클러스터링 키로 사용되며 값에 의해 레코드의 위치가 결정됩니다.
- 클러스터링 인덱스 덕분에 매우 빠르게 처리되고 검색에서 상당히 빈번하게 사용되기에 좀 더 의미있는 칼럼을 선택해야 합니다.

<br>

**프라이머리 키는 반드시 명시할 것**

- PK가 없는것 보다는 AUTO_INCREMENT를 사용해서라도 PK 생성을 권장합니다.
- PK가 없다면 내부적으로 일련번호 칼럼을 추가하는데 이는 사용자에게 보이지 않기에 전혀 접근(사용)할 수 없습니다.
- AUTO_INCREMENT와 똑같이 정의되지만 사용할 수 없기 때문에, 사용할 수 있는 AUTO_INCREMENT를 사용해서라도 PK생성을 권장합니다.
- ROW 기반 복제, InnoDB Cluster에서 모든 테이블의 PK를 가져야 정상적인 복제 성능을 보장하기도 합니다.

<br>

**AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우**

- 여러 칼럼이 복합적으로 PK가 되는경우 PK의 크기가 길어집니다.
    - 세컨더리 인덱스가 필요없다면 그대로 사용해도 좋습니다.
- 다만 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 칼럼을 추가하고, 이를 PK로 설정하면 됩니다.
- 이런 AUTO_INCREMENT로 추가된 PK를 인조 식별자(Surrogate key)라고 합니다.
    - INSERT 위주의 테이블을 AUTO_INCREMENT를 이용한 PK를 설정하는것이 성능 향상에 도움이 됩니다.

<br><br><br>

## ✅ 8.9 유니크 인덱스

- 유니크는 인덱스이며 제약조건이기도 합니다. (유니크 제약조건 추가시 자동으로 인덱스를 추가하므로)
- 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미합니다.
    - 다만 null같은 경우 특정 값이 아니므로 2개이상 저장될 수 있습니다.(유니크 인덱스는 null 허용)

<br><br>

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

구조상으로는 아무런 차이점이 없으므로 유니크 인덱스와 세컨더리 인덱스의 읽기와 쓰기를 성능 관점에서 살펴봅니다.

<br>

**인덱스 읽기**

세컨더리 인덱스는 유니크하지 않으므로 성능이 유니크 인덱스보다 떨어질것 같지만,

레코드 1개를 읽는것의 속도차이는 아무런 차이가 없습니다.

세컨더리 인덱스가 조회사 N개의 레코드를 읽고 유니크 인덱스는 조회시 1개의 레코드를 읽을때 당연히 차이가 발생하겠지만, 이를 평균적으로 봤을때는 큰 차이가 없습니다.

<br>

**인덱스 쓰기**

- 유니크 인덱스는 쓰기 작업을 할때 중복 체크과정이 한 단계 더 필요하므로 세컨더리 인덱스의 쓰기보다 변경 작업이 더 느리게 작동합니다.
- 또한 MySQL에서 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 아주 빈번히 발생합니다.
- 또한 InnoDB 스토리지 엔진에는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼가 사용되지만, 유니크 인덱스는 반드시 중복체크가 필요하므로 작업 자체를 버퍼링하지 못합니다.

<br><br>

### 8.9.2 유니크 인덱스 사용 시 주의사항

- 꼭 필요한 경우 유니크 인덱스를 사용해야 하는데, 단순히 성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지 않는것이 좋습니다.
- 유니크 인덱스나 일반 인덱스나 같은 역할을 하므로 굳이 중복해서 인덱스를 생성할 필요가 없습니다.
- 유일성이 꼭 보장돼야 하는 칼럼에 대해서는 유니크 인덱스를 생성하되, 필요하지 않다면 유니크 인덱스보다는 세컨더리 인덱스를 생성하는 방법도 고려해보면 좋습니다.

<br><br><br>

## ✅ 8.10 외래키

MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성됩니다.

외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없습니다.

InnoDB 외래키 관리에는 중요한 두 가지 특징이 있습니다.

1. **테이블의 변경(쓰기 잠금)이 발생한느 경우에만 잠금 경합(잠금 대기)이 발생합니다.**
2. **외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경함(잠금 대기)을 발생시키지 않는다.**

```sql
CREATE TABLE parent (
		id INT NOT NULL,
		address VARCHAR(100) NOT NULL, PRIMARY KEY (id)
) ENGINE=InnoDB;

CREATE TABLE child (
		id INT NOT NULL,
		pid INT DEFAULT NULL,
		address VARCHAR(100) NOT NULL,
		PRIMARY KEY (id),
		KEY ix_parentid (pid),
		CONSTRAINT child_ibfk_1 FOREIGN KEY (pid) REFERENCES to_parent (id) ON DELETE CASCADE
) ENGINE=InnoDB;

INSERT INTO tb_parents VALUES (1, 'parent-1'), (2, 'parent-2');
INSERT INTO tb_child VALUES (100, 1, 'child-100');
```

<br><br>

### 8.10.1 자식 테이블의 변경이 대기하는 경우

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/7e56d969-3686-448c-a81c-b04fa5b2e0da)


- 1번 커넥션에서 트랜잭션이 시작되고, id가 3인 레코드에 UPDATE를 실행합니다.
    - parent의 id=3인 레코드에 대한 쓰기 잠금 획득
- 이때 2번 커넥션에서 id=100인 child 테이블의 외래키 칼럼을 3으로 변경하게 되면 부모 테이블의 변경 작업이 완료될 때까지 대기하게 됩니다.
- 1번 커넥션이 COMMIT, ROLLBACK되면 그제서야 2번 커넥션의 작업도 즉시 처리됨을 확인할 수 있습니다.
- 자식 테이블의 외래키 칼럼의 변경은 부모 테이블의 확인이 필요합니다.
    - 만약 부모 테이블의 해당 레코드가 쓰기 잠금에 걸려있다면 잠금이 해제될 때까지 기다리게 됩니다.
    **(InnoDB 외래키 관리의 첫 번째 특징)**
    - 다만 자식 테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장은 발생하지 않습니다.
    **(InnoDB 외래키의 두 번째 특징)**

<br><br>

### 8.10.2 부모 테이블의 변경 작업이 대기하는 경우

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/5bdc689f-113b-4f7d-a022-b6962e5dc4f5)


- 커넥션1에서 부모 키 1을 참조하는 자식 테이블 레코드를 변경하면 child의 해당 레코드에 대한 쓰기 잠금을 얻습니다.
- 2번 커넥션에서 id=1인 부모 테이블의 레코드를 삭제하는 경우 child 테이블의 레코드 쓰기 잠금이 해제될 때 까지 기다립니다.
    - 자식 테이블이 생성될때 ON DELETE CASCADE로 외래키의 특성이 정의됐기에 부모 레코드가 삭제되면 자식 레코드도 삭제되어야 하기 때문입니다.

결국 DB에서 외래키를 물리적으로 생성하려면 잠금 경합까지 고려해 모델링을 진행해야 합니다.
물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가되는 경우 참조키가 부모 테이블에 있는지 확인하는것과 더불어 물리적인 외래키의 고려사항은 체크를 위해 연관 테이블의 레코드에 읽기 잠금을 걸어야 합니다. 이런 잠금의 확장은 전체적으로 쿼리의 동시 처리에 영향을 미칩니다.
