- 11.1 쿼리 작성과 연관된 시스템 변수
    - 1.  SQL 모드
        
        MySQL 서버의 sql_mode라는 시스템 설정에는 여러 개의 값이 동시에 설정될 수 있다.
        
        - STRICT_ALL_TABLES: 트랜잭션 지원 여부와 무관하게 모든 스토리지 엔진에 대해 엄격한 모드를 적용
        - STRICT_TRANS_TABLES: 트랜잭션을 지원하는  스토리지 엔진에만 엄격한 모드를 적용
        - ANSI_QUOTES: 홑따옴표만 문자열 값 표기로 사용할 수 있고, 쌍따옴표는 칼럼명이나 테이블명과 같은 식별자를 표기하는 데만 사용할 수 있다.
    - 2 영문 대소문자 구분
        
        초기 DB나 테이블을 생성할 때 대문자 또는 소문자만으로 통일해서 사용하는 편이 좋다.
        
    - MySQL 예약어
        
        직접 MySQL에서 테이블을 생성해 보는 것이 예약어인지 아닌지를 구별하기에 가장 좋은 방법이다. 단 역따옴표로 테이블명이나 칼럼명을 둘러싸지 않고 테이블을 생성해야 에러나 경고를 보여준다.
        
- 11.2 메뉴얼의 SQL 문법 표기를 읽는 방법
    - 대괄호(”[ ]”)는 해당 키워드나 표현식 자체가 선택 사항임을 의미한다. 즉, 대괄호가 있거나 없거나 문법적인 오류가 발생하지 않는다.
    - 파이프(”|”)는 앞과 뒤의 키워드나 표현식 중에서 단 하나만 선택해서 사용할 수 있음을 의미한다. LOW_PRIORITY, DELAYED, HIGH_PRIORITY는 셋 중에서 단 하나만 선택하여 사용할 수 있다.
    - 중괄호(”{}”)는 괄호 내의 아이템 중에서 반드시 하나를 사용해야 하는 경우를 의미한다.
    - “…” 표기는 앞에 명시된 키워드나 표현식의 조합이 반복될 수 있음을 의미한다.
- 11.3 MySQL 연산자와 내장 함수
    - 1.  리터럴 표기법 문자열
        - 문자열
            
            홑따옴표 혹은 쌍따옴표가 문자열에 포함되어 있는 경우 두번 연속해서 사용하면 된다.
            


            
             SQL에서 사용되는 식별자(테이블 명이나 칼럼명 등)가 키워드와 충돌할 때 오라클이나 PostgreSQL에서는 쌍따옴표나 대괄호로 감싸서 충돌을 피한다. MySQL에서는 역따옴표를 감싸서 사용하면 예약어와의 충돌을 피할 수 있다. (아래는 ANSI_QUOTES 설정이니깐 여기는 디폴트 설정을 말하는걸까요..?!)
            
            sql_mode → ANSI_QUOTES일 경우 쌍따옴표를 문자열 리터럴 표기에 사용 불가.
            
            식별자 또한 충돌을 피하려면 쌍따옴표를 사용해야 한다.
            
            운용 중인 애플리케이션에서 sql_mode 설정을 변경하는 것은 상당히 위험하다.
            
        
        - 숫자
            
            숫자로 된 문자열 값과 숫자 값을 비교할 때 문자열 값→숫자 값으로 타입을 변환한 뒤 비교를 진행한다. 문자열 값에 알파벳과 같은 문자가 포함된 경우 숫자 값을 변환할 수 없으므로 이러한 문제점을 제거하기 위해 숫자 값은 숫자 타입의 칼럼에만 저장해야 한다.
            
        
        - 날짜
            
            MySQL 서버가 자동으로 DATE나 DATETIME 값으로 변환하기 때문에 복잡하게 STR_TO_DATE() 같은 함수를 사용하지 않아도 된다.
            
            
        
        - 불리언
            
            테이블의 칼럼을 BOOL로 생성한 뒤에 조회해보면 칼럼의 타입이 TINYINT로 저장되어 있다. 두 단어가 동의어 관계이기 때문이다. 
            
            MySQL에서는 TRUE와 FALSE로 저장하지만 실제로 값을 조회해보면 0과 1로 조회된다.
            
    - 2.  MySQL 연산자
        - 동등(Equal) 비교(=. <⇒)
            
            = : 한쪽이 null 이면 FASLE를 반환한다.
            
            <⇒ :  null또한 값으로 인식하여 1또는 0으로 반환한다.
            
        - 부정(Not-Equal) 비교(<>,≠)
            
            ‘<>’ 와 ‘!=’가 혼용되면 가독성이 떨어지므로 통일해서 사용하는 방법을 권장한다.
            
        - NOT 연산자(!)
            
            TRUE 또는 FALSE 연산의 결과를 반대로 만드는 연산자로 ‘NOT’을 사용한다.
            
            숫자에도 사용이 가능하지만 부정의 결과값을 정확히 예측할 수 없는 경우에는 사용은 자제하는 것이 좋다.
            
        - AND(&&)와 OR(||) 연산자
        - 나누기(/, DIV)와 나머지(%, MOD) 연산자
        - REGEXP 연산자
            
            문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자이며, REGEXP 연산자의 좌측에 비교 대상 문자열 값 또는 문자열 칼럼을, 우측에 검증하고자 하는 정규 표현식을 사용하면 된다.
            
            
            정규식 관련 내용
            
            
            
        - LIKE 연산자
            
            REGEXP 연산자와는 다르게 인덱스를 이용해 처리할 수 있다. LIKE 연산자는 정규 표현식을 검사하는 것이 아니라 어떤 상수 문자열이 있는지 없는지 정도를 판단하는 연산자이다. 
            
            
            ‘Christ%’ 와 같이 검색어 뒤에 와일드카드 문자가 있으면 레인지 스캔을 이용해 검색할 수 있지만 ‘%rist’와 같이 와일드카드가 검색어 앞쪽에 있는 경우는 인덱스의 Left-most 특성으로 인해 레인지 스캔을 사용하지 못하고 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔 방식으로 쿼리가 처리된다.
            
        - BETWEEN 연산자
            
            다른 비교 조건과 결합해 하나의 인덱스를 사용할 때 주의해야할 점이 있다.
            
            
            2번째 쿼리에 emp_no=10001; 이 있어도 BETWEEN은 크다 또는 작다 연산자와 같이 범위를 읽어야 하는 연산자라 표시 범위 내의 모든 인덱스의 범위를 검색해야 한다.
            
            BETWEEN 연산자 대신 IN (sub_query) 방법을 사용하면 옵티마이저가 세미 조인 최적화를 이용해 더 빠른 쿼리로 변환해서 실행한다.
            
            
        - IN 연산자
            
            여러 개의 값에 동등 비교 연산을 수행하는 연산자다. 범위로 검색하는 것이 아니라 여러 번의 동등 비교로 실행하기 때문에 일반적으로 빠르게 처리된다.
            
            - 상수가 사용된 경우 - IN (?, ?, ?)
                
                동등 비교로 인한 빠른 처리
                
            - 서브 쿼리가 사용된 경우 - IN (SELECT … FROM ..)
                
                이 경우 쿼리 최적화가 매우 까다롭다. 하지만 8.0 버전부터 안정화됐다. - 9.3절 ‘ 고급 최적화’
                
                NOT IN 은 동등이 아닌 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로 사용할 수 없다.
                
                23쪽 맨아래 3줄 이해가 안감…! (다시 확인해볼 것.)
                
    - 3.  MySQL 내장 함수
        - NULL 값 비교 및 대체(IFNULL, ISNULL)
            
            IFNULL() 의 반환값은 첫번째 인자가 NULL이 아니면 첫번째 인자 값을, NULL이면 두번째 인자 값을 반환한다.
            
            ISNULL() 은 인자의 표현식이 TRUE(1), NULL이 아니면 FALSE(0)를 반환한다.
            
        - 현재 시각 조회(NOW, SYSDATE)
            
            하나의 SQL에서 모든 NOW() 함수는 같은 값을 가지지만 SYSDATE()는 호출되는 시점에 따라 결괏값이 달라진다.
            
            SLEEP을 걸어놓고 실행하면 SLEEP 이후에 시간으로 SYSDATE()는 결괏값을 반환한다.
            
            SYSDATE()의 두 가지 잠재적 문제점
            
            - SYSDATE() 함수가 사용된 SQL은 레플리카 서버에서 안정적으로 복제되지 못한다.
            - SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못한다.
                
                호출될 때마다 다른 값을 반환하므로 상수가 아니다. 하지만 NOW() 는 쿼리가 실행되는 시점에서 실행되고 값을 할당받아서 그 값을 SQL 문장의 모든 부분에서 사용한다. (반대로 SYSDATE()는 실행되는 시점에 따라 결과값이 달라진다.)
                
                일반적으로 NOW()를 쓰고 이미 SYSDATE()를 사용하고 있다면 sysdate-is-now 시스템 변수를 활성화하는 것이 방법이 될 수 있다.
                
        - 날짜와 시간의 포맷(DATE_FORMAT, STR_TO_DATE)

            SQL에서는 표준 형태로 입력된 문자열은 필요한 경우 자동으로 DATETIME 타입으로 변환되어 처리된다. 하지만 MySQL 서버가 문자열에 사용된 날짜 타입의 포맷을 알 수 없기 때문에 STR_TO_DATE() 함수를 이용해 문자열을 DATETIME 타입으로 변환할 수 있다.
            
            
        - 날짜와 시간의 연산(DATE_ADD, DATE_SUB)
            
            
            첫번째 인자는 연산을 수행할 날짜, 두번째 인자는 더하거나 빼고자 하는 월의 수나 일자의 수등을 입력하면 된다. ADD로 뺄셈까지 처리할 수 있다.
            
        - 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)
            
            UNIX_TIMESTAMP() 함수는 ‘1970-01-01 00:00:00’으로부터 경과된 초의 수를 반환하는 함수
            
            FROM_UNIXTIME() 함수는 인자로 전달한 타임스탬프 값을 DATETIME 타입으로 변환하는 함수다.
            
        - 문자열 처리(RPAD, LPAD / RTRIM, LTRIM, TRIM)
            
            RPAD, LPAD 는 문자열의 좌측 혹은 우측에 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수 : (패딩처리할 문자열, 패딩할 바이트 수, 패딩할 문자)
            
            RTRIM, LTRIM, TRIM 는 문자열의 우측 또는 좌측에 연속된 공백 문자(SPACE, NewLine, TAB 문자)를 제거하는 함수다.
            
        - 문자열 결합(CONTACT)
            
            여러 개의 문자열을 연결해서 하나의 문자열로 반환하는 함수, 인자의 개수 제한은 없다.
            
            만약 인자가 숫자 값이라면 문자열 타입으로 자동 변환 후 연결된다.
            
            CONTACT_WS() 는 문자열을 연결할 때 구분자를 넣어준다.
            
        - GROUP BY 문자열 결합(GROUP_CONCAT)
            
            GROUP_CONCAT() 함수는 값들을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며, 여러 값 중에서 중복을 제거하고 연결하는 것도 가능하다.
            
            또한, 지정한 칼럼의 값들을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용한다. 기본 1KB 설정이기 때문에 자주 사용한다면  group_concat_max_len 시스템 변수로 조정한다.
            
        - 값의 비교와 대체(CASE WHEN … THEN … END)
            
            
            이렇게 CASE WHEN 을 사용하면 남자 사원의 수(1만 2천여 번)만큼 서브쿼리의 실행 횟수를 줄일 수 있다.
            
        - 타입의 변환(CAST, CONVERT)
            
            SQL은 텍스트 기반으로 작동하기 때문에 SQL에 포함된 모든 입력값은 문자열처럼 취급된다. 이럴 때 명시적 타입 변환을 위해 CAST()를 이용하면 된다. CONVERT()도 거의 유사하고 단지 함수의 인자 사용 규칙만 조금 다르다.
            
            
            CONVERT()는 (변환하려는 값 or 표현식, 변환하려는 데이터 타입)
            
            구분자를 USING으로도 사용 가능
            
        - 이진값과 16진수 문자열 변환
            
            HEX() 함수는 이진값을 사람이 읽을 수 있는 16진수의 문자열로 변환하는 함수
            
        - 암호화 및 해시 함수(MD5, SHA, SHA2)
            
            SHA, MD5의 출력 값은 16진수 문자열 형태이다. → CHAR(40) 을 필요로 한다.
            
            MD5() 함수와 SHA() 함수의 결과를 HEX(), UNHEX() 함수를 이용해 문자열에서 이진값으로 또는 그 반대로 변환할 수 있다.
            
            MD5() 함수의 결과 32글자가 차지하는 바이트 수와 메타 정보의 공간을 포함한 바이트 수다. 이 공간을 더 줄이고자 한다면 UNHEX()를 이용해 이진값으로 만들면 메모리 사용량을 줄일 수 있다.
            
        - 처리 대기(SLEEP)
            
            SQL의 개발이나 디버깅 용도로 잠깐 대기하거나 일부러 쿼리의 실행을 오랜 시간 유지하고자 할 때 사용한다.
            
        - 벤치마크
            
            BENCHMARK() 함수는 SLEEP() 함수와 같이 디버깅이나 간단한 함수의 성능 테스트용으로 아주 유용한 함수다. BENCHMARK(반복해서 수행할 횟수, 반복해서 실행할 표현식)
            
            두 번째 인자의 표현식은 반드시 스칼라값을 반환하는 식이어야 한다. 
            
            BENCHMARK는 반환 값이 중요하지 않으며, 단지 지정한 횟수만큼 반복 실행하는 데 얼마나 시간이 소요됐는지가 중요할 뿐이다. 
            
            단지 두 개의 동일 기능을 상대적으로 비교 분석하는 용도로 사용할 것을 권장한다.
            
        - IP 주소 변환(INET_ATON, INET_NTOA)
            
            MySQL에서는 INET_ATON, INET_NTOA 함수를 이용해 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장할 수 있게 제공한다.
            
            INET_ATON() : 문자열 IPv4 → 정수형
            
            INET_NTOA() : 정수형의 IPv4 → 문자열 IPv4
            
        - JSON 포맷
            
            JSON_PRETTY() 함수를 이용하면 JSON 컬럼의 값을 읽기 쉬운 포맷으로 변환해준다.
            
            
        - JSON 필드 추출
            
            JSON_EXTRACT(JSON 데이터가 저장된 칼럼 or 도큐먼트 자체, 가져오고자 하는 필드의 JSON 경로)
            
            
            JSON_UNQUOTE()를 사용하면 필드명 쌍따옴표를 제거할 수 있다. 
            
            (MySQL 서버에서는 ->> 로 사용할 수 있다.)
            
            MySQL 서버에서는 JSON 연산자를 제공한다.
            
            
        - JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)
            
            
            doc 에 해당 JSON 필드를 가지고 있는지 확인하는 함수이다.
            
        - JSON 오브젝트 생성(JSON_OBJECT)
            
            RDBMS 칼럼의 값을 이용해 JSON 오브젝트를 생성하는 함수다.
            
            
        - JSON 칼럼으로 집계(JSON_OBJECTAGG & JSON_ARRAYAGG)
            
            JSON 배열 또는 도큐먼트를 생성하는 함수다.
            
            
            JSON_OBJECTAGG(Key, Value) → 키, 밸류 쌍으로 표현된다.
            
        - JSON 데이터를 테이블로 변환(JSON_TABLE)
            
            JSON 데이터의 값들을 모아서 RDBMS 테이블을 만들어 반환해준다.
            
