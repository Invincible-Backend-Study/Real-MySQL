# 📌 쿼리 작성 및 최적화1

- `DDL`(Data Definition Language): DB나 테이블의 구조를 변경하기 위한 문장
- `DML`(Data Manipulation Language): 테이블의 데이터를 조작(읽고, 쓰기) 하기 위한 문장

SQL은 데이터를 요청하기 위한 (What)언어입니다. 어떻게(How) 데이터를 읽을지 표현하진 않으므로 빠른 쿼리 수행을 위해 DBMS 서버에서 쿼리어 어떻게 요청을 처리할지 예측할 수 있어야 하므로 `SQL 작성 방법`, `규칙`, `내부적인 처리 방식(옵티마이저)`에 대해 지식이 필요합니다.

<br><br><br>

## ✅ 11.1 쿼리 작성과 연관된 시스템 변수

SQL 작성 규칙은 MySQL 서버의 시스템 설정에 따라 달라집니다.
(대소문자 구분, 문자열 표기 방법 등)

<br><br>

### 11.1.1 SQL 모드

MySQL 서버의 `sql_mode` 시스템 설정에는 여러 개의 값을 구분자(,)를 이용해 동시 설정될 수 있습니다.

> `주의점`
문장 작성 규칙 뿐만 아니라 MySQL 서버 내부적으로 자동 실행되는 데이터 타입 변환 및 기본값 제어 등과 관련된 옵션도 가지고 있기에 가능한 변경하지 않는것이 좋습니다.
또한 하나의 복제 그룹에 속한 모든 MySQL 서버들은 동일한 sql_mode 시스템 변수를 유지하는게 좋습니다.
8.0부터의 기본값은 다음 옵션으로 구성됩니다.
> 
> 
> ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/51983d93-b574-4b7d-b400-dbb1b33bc4a9)

> 

- `STRICT_ALL_TABLES & STRICT_TRANS_TABLES`
    - INSERT, UPDATE시 칼럼의 타입과 저장되는 값의 타입이 다를때 자동으로 타입 변경을 수행하는데, 타입이 변환이 어렵거나 최대 길이를 초과할때 계속 실행 혹은 에러 여부를 결정하는 옵션입니다.
    - 전자의 경우 InnoDB 같이 트랜잭션 지원 스토리지 엔진에만 strict mode를 적용하고 후자는 모든 스토리지 엔진에 대해 strict mode를 적용합니다.
- `ANSI_QUOTES`
    - 문자열 값(리터럴) 표현을 위해 홑따옴표와 쌍따옴표를 동시에 사용할 수 있는지 여부를 결정합니다.
    - **끄면 홑따옴표만 문자열 값 표기로 사용 가능**하고 쌍따옴표는 칼럼명, 테이블명과 같은 식별자 표기에만 사용가능
- `ONLY_FULL_GROUP_BY`
    - 켜져 있다면 GROUP BY절에 포함되어 있지 않은 칼럼을 SELECT, HAVING절에 이용할 수 없습니다.
- `PIPE_AS_CONCAT`
    - ||는 OR연산자 이지만 해당 옵션을 설정하면 오라클과 같이 문자열 연결 연산자(CONCAT)으로 사용할 수 있습니다.
- `PAD_CHAR_TO_FULL_LENGTH`
    - MySQL에선 CHAR, VARCHAR 모두 유효 문자열 뒤 공백 문자는 제거되어 반환하지만 해당 옵션을 키면 CHAR 타입 칼럼에서 뒤쪽의 공백이 제거되지 않고 반환합니다.
- `NO_BACKSLASH_ESCAPES`
    - 해당 옵션을 설정하면 역슬래시 문자를 이스케이프 용도로 사용하지 못하고 역슬래시 문자를 다른 문자와 동일하게 취급합니다.(원래는 가능함)
- `IGNORE_SPACE`
    - 스토어드 프로시저, 함수의 이름 뒤에 공백이 있다면 에러가 출력될 수 있는데 해당 설정을 적용하면 프로시저, 함수명, 괄호 사이의 공백은 무시합니다. (내장 함수에만 적용됨)
    - 다만 내장 함수는 모두 예약어로 간주되어 테이블, 칼럼 이름으로 사용될 수 없습니다. (backtick을 이용하면 사용가능)
- `REAL_AS_FLOAT`
    - REAL 타입은 부동소수점 타입인 DOUBLE과 동일하게 취급되지만 옵션을 설정하면 또다른 부동소수점 타입인 FLOAT 타입의 동의어로 바뀝니다.
- `NO_ZERO_IN_DATE & NO_ZERO_DATE`
    - 옵션 설정시 DATE, DATETIME 타입 칼럼에 “2020-00-00” or “0000-00-00”과 같은 잘못된 날짜를 저장하는것이 불가능합니다.
- `ANSI`
    - 여러가지 옵션을 조합해 MySQL 서버가 최대한 SQL 표준에 맞게 동작하게 합니다.
    - `REAL_AS_FLOAT`, `PIPES_AS_CONCAT`, `ANSI_QUOTES`, `IGNORE_SPACE`, `ONLY_FULL_GROUP_BY`의 조합으로 구성된 모드입니다.
- `TRADITIONAL`
    - `STRICT_ALL_TABLES & STRICT_TRANS_TABLES`과 비슷하지만 조금 더 엄격한 방식으로 SQL 작동을 제어합니다.
    - `STRICT_TRANS_TABLES`, `STRICT_ALL_TABLES`, `NO_ZERO_IN_DATE`, `NO_ZERO_DATE`, `ERROR_FOR_DIVISION_BY_ZERO`, `NO_ENGINE_SUBSTITUTION` 모드의 조합으로 구성됩니다.
    - 해당 모드 활성화시 이전에는 경고로 처리되던 상황들이 에러로 바뀌며 SQL 문장이 실패합니다.
    
<br><br>

### 11.1.2 영문 대소문자 구분

- MySQL 서버가 설치된 운영체제에 따라 테이블명의 대소문자를 구분합니다.
    - DB, 테이블이 디스크의 dir, file로 매핑되기 떄문입니다.
- 윈도우는 구분하지 않지만 유닉스 계열은 대소문자를 구분합니다.
- 대소구분 영향을 받지 않으려면 lower_case_table_names 시스템 변수를 설정하면됩니다.
    - `0` - DB나 테이블명에 대해 대소구분(default값)
    - `1` - 모두 소문자 저장(대소구분X)
    - `2` - 윈도우, macOS적용 저장은 대소문자를 구분하지만 쿼리는 구분하지 않음

가능하면 초기 생성시 대문자, 소문자 중 하나로 통일하는편이 좋습니다.

<br><br>

### 11.1.3 MySQL 예약어

- DB, 테이블을 예약어를 사용하려면 `백틱`, `쌍따옴표`로 감싸야 합니다.
- 하지만, 예약어는 사용하지 않는것이 좋으므로 생성시 감싸지 않는것을 권장합니다.
- 그렇게 되면 예약어를 사용했을때 에러로 알려줍니다.

<br><br><br>

## ✅ 11.2 메뉴얼의 SQL 문법 표기를 읽는 방법

MySQL 메뉴얼에 명시된 SQL 문법은 장황하지만, 해당 버전에 맞게 표기했기에 그것만큼 정확한것은 없습니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/caef2424-4f55-4597-abd1-f3bb34b6902a)


- 대문자로 표현된 단어는 모두 SQL 키워드를 의미합니다. 
(쿼리 작성시 대소문자를 특별히 구분하지 않아도 됨)
- 이텔릭체로 표현된 단어는 사용자가 선택해서 작성하는 토큰을 의미합니다.
(주로 테이블명, 칼럼명, 표현식)
    - SQL 키워드, 식별자가 아니라면 하단에 더 상세한 문법을 설명합니다.
    - 단말노드도 중요 사항이나 주의사항이 있으면 메뉴얼의 하단에서 별도 설명이 추가되기에 쉽게 참조 가능합니다? HAVETOFIND 단말노드가 뭐죵
- `[, ]`
    - 키워드, 표현식 자체가 선택사항 있거나 없어도 문법적인 오류가 없습니다.
- `|`
    - 앞과 뒤의 키워드나 표현식 중에서 단 하나만 선택해 사용할 수 있음을 의미합니다.
- `{, }`
    - 괄호 내 아이템 중 반드시 하나를 사용해야 하는 경우를 의미합니다.
- `...`
    - 앞에 명시된 키워드나 표현식의 조합이 반복될 수 있음을 의미합니다.

---

<br><br><br>

## ✅ 11.3 MySQL 연산자와 내장 함수

- ANSI 표준 형태가 아닌것도 포함된 MySQL에서만 사용되는 연산자나 표기법이 있습니다.
- 다만 SQL의 가독성을 높이기 위해 ANSI 표준 형태의 연산자 사용을 권장합니다.
- 각 DBMS의 내장 함수는 거의 같은 기능을 제공하지만 이름이 호환되는 것은 거의 없습니다.

<br><br>

### 11.3.1 리터럴 표기법 문자열

<br>

**11.3.1.1 문자열**

- SQL 표준은 항상 홑따옴표를 사용해서 표시하지만, MySQL은 쌍따옴표를 사용해 표기할 수 있습니다.
- 따라서 문자열 값에 홑따옴표가 있다면 쌍따옴표와 같이 혼합해 이런 문제를 피할 수 있습니다.
    
    ```sql
    # SQL 표준
    SELECT * FROM departments WHERE dept_no='d''001';
    SELECT * FROM departments WHERE dept_no='d"001';
    # MySQL에서만 지원하는 방식
    SELECT * FROM departments WHERE dept_no="d'001";
    SELECT * FROM departments WHERE dept_no="d""001";
    ```
    

- 또한 식별자가 예약어와 충돌할때는 `백틱`을 사용하여 예약어와의 충돌을 막습니다.
- sql_mode에 ANSI_QUOTES 설정을 하면 쌍따옴표는 문자열 리터럴 표기에 사용할 수 없고 설정하게 되면 테이블명 및 칼럼명의 충돌을 피하기 위해 백틱이 아닌 쌍따옴표를 사용합니다.
    
    ```sql
    # ANSI_QUOTES 적용시 사용가능한 방식
    SELECT * FROM departments WHERE dept_no='d''001';
    SELECT * FROM departments WHERE dept_no='d"001';
    
    CREATE TABLE tab_test ("table" VARCHAR(20) NOT NULL, ...);
    SELECT "column" FROM tab_test;
    ```
    
- SQL 표준 표기법만 사용하도록 강제하려면 sql_mode 에 `ANSI`를 설정하면 됩니다. (운용중인 애플리케이션에서는 변경하지 않도록 주의)

---

<br>

**11.3.1.2 숫자**

- 숫자 값을 상수로 사용할 때는 따옴표없이 숫자 값을 입력합니다. (다른 DBMS와 동일)
- 문자열  형태로 따옴표를 사용해도 비교 대상이 숫자이거나 숫자 타입 칼럼이면 숫자값으로 자동 변환합니다.
- 다만 한가지 주의할 부분이 있습니다.
    
    ```sql
    SELECT * FROM tab_test WHERE number_column='10001'; 
    SELECT * FROM tab_test WHERE string_column=10001
    ```
    
    - 첫번째 경우는 ‘10001’하나만 문자 → 숫자로 변환해 비교합니다.
    - 하지만 두번째는 10001과의 비교를 위해 기존 문자열로 저장된 모든 칼럼값을 숫자로 변환해 비교를 수행해야 합니다.
    
    결국 두번째 값은 인덱스가 있어도 이용하기 어렵고 알파벳과 같은 문자가 포함되면 쿼리 자체가 실패할 수 있습니다.
    

---

<br>

**11.3.1.3 날짜**

- 다른 DBMS는 명시적으로 변환 코드가 필요하지만 MySQL은 정해진 형태의 날짜 포맷으로 표기하면 자동으로 DATE, DATETIME값으로 변환합니다.(인덱스 사용도 문제 없음)

```sql
# 동일한 쿼리
SELECT * FROM dept_emp WHERE from_date='2011-04-29';
SELECT * FROM dept_emp WHERE from_date=STR_TO_DATE('2011-04-29','%Y-%m-%d');
```

---

<br>

**11.3.1.4 불리언**

- BOOL, BOOLEAN이라는 타입이 있지만 TINYINT 타입에 대한 동의어 입니다.
- MySQL에선 TRUE 또는 FALSE형태로 비교하거나 값을 저장할 수 있습니다.
(다만 숫자 타입의 칼럼에도 모두 적용되는 비교방식입니다.)

```sql
CREATE TABLE tb_boolean (bool_value BOOLEAN);
INSERT INTO tb_boolean VALUES (FALSE);

SELECT * FROM tb_boolean WHERE bool_value=FALSE;
SELECT * FROM tb_boolean WHERE bool_value=TRUE;
```

- TRUE, FALSE는 1, 0과 같이 정수로 매핑해서 사용합니다. (TRUE가 1이외의 값이 될 수 없음)
    
    ```sql
    INSERT INTO tb_boolean VALUES (FALSE), (TRUE), (2), (3), (4), (5); 
    
    mysql> SELECT * FROM tb_boolean WHERE bool_value IN (FALSE, TRUE);
    +------------+
    | bool_value |
    +------------+
    |          0 |
    |          1 |
    +------------+
    
    mysql> select * from tb_boolean;
    +------------+
    | bool_value |
    +------------+
    |          0 |
    |          1 |
    |          2 |
    |          3 |
    |          4 |
    |          5 |
    +------------+
    
    ```
    

두 개의 불리언 값으로 매핑되지 않는다면 버그로 연결될 수 있습니다. 따라서 불리언 타입을 사용하려면 ENUM 타입으로 관리하는게 좀 더 명확하고 실수할 가능성도 줄일 수 있습니다.

<br><br>

### 11.3.2 MySQL 연산자

**11.3.2.1 동등(Equal) 비교(`=`, `<=>`)**

- mysql은 “=” 기호를 사용해 비교를 수행하고 “<=> “ 연산자 또한 제공합니다.
- 기본적으로 동일하지만 후자의 경우 부가적으로 NULL값에 대한 비교까지 수행합니다.(NULL-Safe 비교 연산자)

```sql
SELECT 1 = 1, NULL = NULL, 1 = NULL;
+-------+-------------+----------+
| 1 = 1 | NULL = NULL | 1 = NULL |
+-------+-------------+----------+
|     1 |        NULL |     NULL |
+-------+-------------+----------+

SELECT 1 <=> 1, NULL <=> NULL, 1 <=> NULL;
+---------+---------------+------------+
| 1 <=> 1 | NULL <=> NULL | 1 <=> NULL |
+---------+---------------+------------+
|       1 |             1 |          0 |
+---------+---------------+------------+
```

`<=>` 는 NULL도 하나의 값으로 인식하고 비교하는 방법입니다.

---

<br>

**11.3.2.2 부정(Not-Equal) 비교(<>, !=)**

- <>, != 모두 특별히 문제되지 않지만 통일해서 사용하길 권장합니다.

---

<br>

**11.3.2.3 NOT 연산자(!)**

- TRUE, FALSE 연산의 결과를 반대로 만들때 사용됩니다.
- NOT, “!”는 불리언 값 외에도 숫자, 문자에도 사용할 수 있지만, 결괏값을 정확하게 예측할 수 없는 경우엔 자제하는것이 좋습니다.

```sql
SELECT ! 1;
+-----+
| ! 1 |
+-----+
|   0 |
+-----+

SELECT !FALSE;
+--------+
| !FALSE |
+--------+
|      1 |
+--------+

SELECT NOT 1;
SELECT NOT 0;
SELECT NOT (1=1);
```

---

<br>

**11.3.2.4 AND(&&)와 OR(||) 연산자**

- 보통 DBMS에선 AND, OR를 사용하지만 mysql은 `&&`, `||`도 허용 합니다.
- 다만 ||의 경우 sql_mode의 PIPE_AS_CONCAT 설정을 통해 concat 역할로 사용할 수 있기에 다른 용도로 사용될 수 있는 &&, || 사용을 자제하는 것이 좋습니다.
- AND, OR가 동시에 사용됐을때 우선순위는 AND가 더 높습니다.

---

<br>

**11.3.2.5 나누기(/, DIV)와 나머지(%, MOD) 연산자**

- `나누기는 / 연산자를 사용`하고, 만약 몫의 `정수부만 취하고 싶다면 DIV 연산자`를 사용합니다.
- 나머지를 가져오려면 %, MOD를 사용합니다.

```sql
SELECT 29 / 9; # 소수점 까지 계산
SELECT 29 DIV 9; # 정수까지만 계산

# 나머지 구하기
SELECT MOD(29, 9);
SELECT 29 MODE 9;
SELECT 29 % 9
```

---

<br>

**11.3.2.6 REGEXP 연산자**

- 문자열 값이 어떤 패턴을 만족하는지 확이낳는 연산자입니다.
- RLIKE는 REGEXP와 똑같은 비교를 수행합니다. (정규 표현식을 비교하는 연산자)
- REGEXP 연산자 좌측은 비교 대상, 우측은 정규 표현식을 작성합니다.
- 정규표현식은 POSIX 표준으로 구현돼 있습니다.

```sql
SELECT 'abc' REGEXP '^[x-z]';

+-----------------------+
| 'abc' REGEXP '^[x-z]' |
+-----------------------+
|                     0 |
+-----------------------+
```

REGEXP 조건 비교는 인덱스 레인지 스캔을 사용할 수 없습니다. 따라서 WHERE 조건절에 해당 연산자를 사용한 조건을 **단독으로 사용하는 것은 성능상 좋지 않습니다**.
(가능하면 작업 범위 결정 조건과 같이 사용하길 권장)

---

<br>

**11.3.2.7 LIKE 연산자**

- LIKE는 인덱스를 이용해 처리할 수 있기에 REGEXP보다 더 많이 사용됩니다.
- LIKE는 비교 대상 문자열의 처음부터 끝까지 일치하는 경우에만 TRUE를 반환합니다.
- `%`: 0또는 1개 이상의 모든 문자에 일치(내용 상관 없이)
- `_`: 정확히 1개의 문자에 일치(내용 상관 없이)
- 만약 %, _ 문자 자체를 사용하고 싶다면 `\%` `\_`와 같이 이스케이프 문자를 적용하면 됩니다.
- %, _가 검색어 뒤쪽에 있으면 인덱스 레인지 스캔이 가능하지만 앞쪽에 있다면 사용할 수 없습니다.
    - 인덱스의 왼쪽값 기준 오른쪽 값이 정렬되어 있는 Left-most 특성으로 인해 발생함

---

<br>

**11.3.2.8 BETWEEEN 연산자**

- 크거나 작다 + 작거나 같다를 합친 연산자 입니다.
- 다만 BETWEEN 연산자와 + 다른 비교 조건에서 하나의 인덱스를 사용할때 주의해야 할 점이 있습니다.

```sql
# dept_emp에는 (dept_no, emp_no) PK가 존재
# (1)
SELECT * FROM dept_emp
WHERE dept_no='d003' AND emp_no=10001;

# (2)
SELECT * FROM dept_emp
WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no=10001;
```

- (1)쿼리는 WHERE의 2개 조건 모두 작업 범위 결정 조건으로 사용됩니다.
- (2)쿼리는 크다 작다와 같이 범위를 읽어야 하므로 `d003 ~ d005`까지의 모든 범위를 검색해야 하므로 `emp_no=10001`은 필터링 조건으로밖에 사용되지 못합니다.
- BETWEEN은 크다, 작다 비교를 묶어두었기에 IN 연산자 처리 방법(동등 비교)와는 다릅니다.
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/c698a300-a12e-4c8e-87ea-0ca7b9fa502c)

    
    - **IN 연산자는 여러 개의 동등 비교를 하나로 묶은 것과 같은 연산자라 IN과 동등 비교 연산자는 같은 형태로 인덱스를 사용합니다.**
    - 다만 BETWEEN은 범위를 검색하므로 많은 레코드를 읽고 1건의 데이터만 반환함을 알 수 있습니다.
    
    ```sql
    # 따라서 아래와 같이 쿼리를 변경할 수 있습니다.
    SELECT * 
    FROM dept_emp
    WHERE dept_no IN ('d003', 'd004', 'd005')
       AND emp_no=10001;
    ```
    

- 위 예제 처럼 여러 칼럼의 인덱스에서 인덱스 앞쪽 칼럼의 선택도가 떨어진다면 IN으로 변경해 쿼리 성능을 개선할 수 있습니다.
    
    ```sql
    EXPLAIN 
    SELECT * FROM dept_emp USE INDEX(PRIMARY)
    		WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no=10001;
    +----+-------------+----------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
    | id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref  | rows   | filtered | Extra       |
    +----+-------------+----------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
    |  1 | SIMPLE      | dept_emp | NULL       | range | PRIMARY       | PRIMARY | 20      | NULL | 165571 |     0.00 | Using where |
    +----+-------------+----------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
    
    EXPLAIN 
    SELECT * FROM dept_emp USE INDEX(PRIMARY)
    		WHERE dept_no IN ('d003', 'd004', 'd005') AND emp_no=10001;
    +----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    | id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | dept_emp | NULL       | range | PRIMARY       | PRIMARY | 20      | NULL |    3 |   100.00 | Using where |
    +----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    ```
    
    → 위 예제는 PK만을 이용해 비교하기 위해 힌트를 주었습니다.
    
    - 두 쿼리 모두 인덱스 레인지 스캔을 하지만, 검색하는 rows수의 예측에서 큰 차이가 발생합니다.
    - BETWEEN의 경우 전체 범위를 검색해야 하기때문에 훨씬 많은 rows가 표시됩니다.
    - 반면에 IN의 경우 `3개의 IN조건 * 1개의 emp_no 조건`으로 총 3개의 레코드만 비교해보면 됩니다.

- BETWEEN → IN으로 변경하려면 이전에는 직접 IN 조건을 작성해줘야 했지만 8.0부터는 `IN (subquery) 형태로 작성하면 옵티마이저가 세미 조인 최적화를 이용해 더 빠른 쿼리로 변환`하여 실행합니다.
    
    ```sql
    SELECT * 
    FROM dept_emp USE INDEX(PRIMARY)
    WHERE dept_no IN (
    	     SELECT dept_no
           FROM departments
           WHERE dept_no BETWEEN 'd003' AND 'd005')
      AND emp_no=10001;
    
    # departments의 dept_no는 PK이므로 조인도 활용 가능 -> 자동 세미 조인 최적화를 명시적으로
    SELECT * FROM departments d
       INNER JOIN dept_emp de USE INDEX(PRIMARY) ON de.dept_no=d.dept_no AND de.emp_no=10001
    WHERE d.dept_no BETWEEN 'd003' AND 'd005';
    
    ```
    

---

<br>

**11.3.2.9 IN 연산자**

- 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자
- 범위가 아니라 N번의 동등 비교로 실행되기에 빠르게 처리됩니다.
- 두 가지 형태로 구분해 생각해볼 수 있습니다.
    - 상수가 사용된 경우 - IN (?, ?, ?)
    - 서브쿼리가 사용된 경우 - IN (SELECT … FROM …)

- 상수의 경우 동등 비교와 동일하게 작용하므로 매우 빠르게 쿼리가 처리 됩니다.
(8.0 이전에는 지원하지 않았던 튜플사용도 지원해줍니다.)
    
    ```sql
    EXPLAIN
    SELECT *
    FROM dept_emp
    WHERE (dept_no, emp_no)
     IN (('d001',10017), ('d002',10144), ('d003',10054));
    
    +----+-------------+----------+------------+-------+---------------------------+---------+---------+------+------+----------+-------------+
    | id | select_type | table    | partitions | type  | possible_keys             | key     | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+----------+------------+-------+---------------------------+---------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | dept_emp | NULL       | range | PRIMARY,ix_empno_fromdate | PRIMARY | 20      | NULL |    3 |   100.00 | Using where |
    +----+-------------+----------+------------+-------+---------------------------+---------+---------+------+------+----------+-------------+
    ```
    
    - `key_len: 20`
        - dept)emp 칼럼(4글자 * 4byte) + emp_no(4byte)를 모두 이용해 인덱스 레인지 스캔을 실행함을 알 수 있습니다.
- 8.0 버전부터는 IN (subquery)같은 세미 조인의 최적화가 많이 안정화 됐습니다.
- NOT IN의 실행 계획은 인덱스 풀 스캔으로 표시되는데 부정형이므로 인덱스를 처리 범위를 줄이는 조건으로 사용할 수 없기 때문입니다.
    - NOT IN 연산자와 PK를 사용할때 나타나는 인덱스 레인지 스캔의 경우 PK가 클러스터링 키이기 때문에 나타나는거지 IN과 같은 효율적인 실행임을 의미하진 않습니다.

---

<br><br>

### 11.3.3 MySQL 내장 함수

mysql의 함수는 기본 제공 내장함수와 사용자가 직접 작성해서 추가할 수 있는 사용자 정의 함수(User Defined Function)으로 구분됩니다.

사용자 정의 함수는 C/C++ API를 이용해 직접 만들어 추가할 수 있습니다.

내장 함수 및 사용자 정의 함수는 스토어드 프로그램으로 작성되는 프로시저, 스토어드 함수와는 다릅니다.

<br>

**11.3.3.1 NULL 값 비교 대체 (IFNULL, ISNULL)**

- IFNULL()은 NULL이라면 다른 값으로 대체하는 용도로 사용됩니다.
    - 2개의 인자를 넘기며 첫번째 인자는 NULL인지 체크할 칼럼, 표현식을 두번째 인자는 첫번째 인자가 NULL일경우 대체값, 칼럼을 설정합니다.
- ISNULL() 인자로 전달한 표현식, 칼럼의 값이 NULL인지 아닌지를 비교하여 TRUE(1), FALSE(0)을 반환합니다.

```sql
SELECT IFNULL(NULL, 1); # 1반환

SELECT IFNULL(0, 1); # 0 != null 이므로 0반환

SELECT ISNULL(0); # FALSE(0)반환 -> NULL 아니므로

SELECT ISNULL(1/0); # 1/0은 NULL 반환함 -> 1반환
```

---

<br>

**11.3.3.2 현재 시각 조회(NOW, SYSDATE)**

- NOW(), SYSDATE()모두 현재 시간을 반환하는 함수로 같은 기능을 수행합니다만 작동방식에 차이가 있습니다.
- 하나의 SQL에서 모든 NOW()함수는 같은 값을 가집니다.
- SYSDATE()는 하나의 SQL이어도 호출되는 시점에 따라 결과값이 달라집니다.

```sql
SELECT NOW(), SLEEP(2), NOW();
+---------------------+----------+---------------------+
| NOW()               | SLEEP(2) | NOW()               |
+---------------------+----------+---------------------+
| 2024-01-28 15:38:13 |        0 | 2024-01-28 15:38:13 |
+---------------------+----------+---------------------+

SELECT SYSDATE(), SLEEP(2), SYSDATE();
+---------------------+----------+---------------------+
| SYSDATE()           | SLEEP(2) | SYSDATE()           |
+---------------------+----------+---------------------+
| 2024-01-28 15:38:27 |        0 | 2024-01-28 15:38:29 |
+---------------------+----------+---------------------+
```

- SYSDATE()는 다음과 같은 잠재적인 문제가 있습니다.
    - SYSDATE() 사용 SQL은 레플리카 서버에서 안정적으로 복제되지 못함
    - SYSDATE()와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못함

- SYSDATE()사용시 인덱스를 효율적으로 사용하지 못하는 문제
    
    ```sql
    EXPLAIN
    SELECT emp_no, salary, from_date, to_date
    FROM salaries
    WHERE emp_no=10001 AND from_date > NOW();
    +----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    | id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | salaries | NULL       | range | PRIMARY       | PRIMARY | 7       | NULL |    1 |   100.00 | Using where |
    +----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    
    EXPLAIN
    SELECT emp_no, salary, from_date, to_date
    FROM salaries
    WHERE emp_no=10001 AND from_date > SYSDATE();
    +----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
    | id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | salaries | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |   17 |    33.33 | Using where |
    +----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+-------------
    ```
    
    - SYSDATE() 호출마다 다른 값을 반환하므로 상수가 아닙니다. 따라서 PK를 온전히 활용하지 못합니다.
    - 반면에 NOW()는 SQL 모든 부분에서 동일한 값을 반환하므로(상수) 쿼리가 1시간짜리라도 항상 같은 값을 보장합니다.
- SYSDATE()를 사용하지 않는것이 좋지만 사용하고 있다면 my.cnf, my.ini에 sysdate-is-now 시스템 변수를 넣어 NOW()함수와 같이 동작하도록 설정할 수 있습니다.

---

<br>

**11.3.3.3 날짜와 시간의 포맷(DATE_FORMAT, STR_TO_DATE)**

- DATE_FORMAT()은 DATETIME 타입의 칼럼이나 값을 원하는 형태의 문자열로 변환할 수 있습니다.
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/38b252f6-91c2-4dbc-b7c3-72dbb5af4c4f)

    
    ```sql
    SELECT DATE_FORMAT(NOW(), '%Y-%m-%d') AS current_dt;
    +------------+
    | current_dt |
    +------------+
    | 2020-08-23 |
    +------------+
    
    SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s') AS current_dttm;
    +---------------------+
    | current_dttm        |
    +---------------------+
    | 2020-08-23 15:06:45 |
    +---------------------+
    ```
    
- `년-월-일 시:분:초` 형태의 경우 자동으로 DATETIME 타입으로 으로 변환됩니다.
- 만약 mysql서버가 모르는 형태라면 명시적으로 `STR_TO_DATE()`를 이용해 문자열을 DATETIME타입으로 변환할 수 있습니다.
    
    ```sql
    SELECT STR_TO_DATE('2020-08-23','%Y-%m-%d') AS current_dt;
    +------------+
    | current_dt |
    +------------+
    | 2020-08-23 |
    +------------+
    
    SELECT STR_TO_DATE('2020-08-23 15:06:45','%Y-%m-%d %H:%i:%s') AS current_dttm;
    +---------------------+
    | current_dttm        |
    +---------------------+
    | 2020-08-23 15:06:45 |
    +---------------------+
    ```
    

---

<br>

**11.3.3.4 날짜와 시간의 연산(DATE_ADD, DATA_SUB)**

- 날짜의 시간을 더하거나 뺄때 사용됩니다 (DATE_ADD로도 빼기 처리할 수 있음)
- 2개의 인자가 필요한데 각각 연산을 수행할 날짜와, 더하거나 빼고자하는 월의 수, 일의 수를 입력합니다.
- 두번째 인자는 `INTERVAL n [YEAR, MONTH, DAY, HOUR, MINUTE, SECOND,...]` 과 같은 형태로 입력해야 합니다.
    - n은 빼거나 더하고자 하는 값이고 뒤의 단위로 연,월,일,시,분,초가 결정됩니다.

```sql
SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS tomorrow;
+---------------------+
| tomorrow            |
+---------------------+
| 2020-08-24 15:11:07 |
+---------------------+

SELECT DATE_ADD(NOW(), INTERVAL -1 DAY) AS yesterday;
+---------------------+
| yesterday           |
+---------------------+
| 2020-08-22 15:11:07 |
+---------------------+
```

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/0bc21ddf-1c67-4037-9b76-449173419c63)


---

<br>

**11.3.3.5 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME)**

- `UNIX_TIMESTAMP()`는 1970-01-01 00:00:00으로부터 경과된 초의 수를 반환하는 함수
    - 다른 운영체제, 프로그래밍 언어에서 같은 방식으로 타임스탬프를 산출하면 상호호환이 가능합니다.
    - 인자 없이 넘겨주면 현재 날짜와 시간의 타임스탬프 값을 반환하고 인자로 특정 날짜를 전달하면 해당 날짜를 기준으로 계산합니다.
- `FROM_UNIXTIME()` 함수는 `UNIX_TIMESTAMP()`와 반대로 인자로 전달한 타임스탬프 값을 DATETIME 타입으로 반환합니다.

```sql
SELECT UNIX_TIMESTAMP();
+------------------+
| UNIX_TIMESTAMP() |
+------------------+
|       1598163535 |
+------------------+

SELECT UNIX_TIMESTAMP('2020-08-23 15:06:45');
+---------------------------------------+
| UNIX_TIMESTAMP('2020-08-23 15:06:45') |
+---------------------------------------+
|                            1598162805 |
+---------------------------------------+

SELECT FROM_UNIXTIME(UNIX_TIMESTAMP('2020-08-23 15:06:45'));
+------------------------------------------------------+
| FROM_UNIXTIME(UNIX_TIMESTAMP('2020-08-23 15:06:45')) |
+------------------------------------------------------+
| 2020-08-23 15:06:45                                  |
+------------------------------------------------------+
```

- TIMESTAMP의 값은 4바이트 숫자 타입으로 지정되기에 `1970-01-01 00:00:01 ~ 2038-01-09 03:14:07` 범위의 날짜 값만 가능합니다.
(위 두 함수도 해당 범위까지만 사용 가능)

---

<br>

**11.3.3.6 문자열 처리(RPAD, LPAD / RTRIM, LTRIM, TRIM)**

- RPAD(), LPAD()는 문자열 좌측, 우측에 문자를 덧붙여 지정된 길이의 문자열로 만듭니다.
    - 3개의 인자가 필요한데 각각 `패딩 처리를 할 문자열`, `패딩을 적용한 문자열의 최대 길이`, `패딩할 문자열`을 의미합니다.
- RTRIM(), LTRIM()은 문자열 우측, 좌측에 연속된 공백문자를 제거하는 함수입니다. TRIM()은 양쪽을 전부 제거합니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/5c2c3d42-d56a-4cd4-bdd2-f0516683620d)


---

<br>

**11.3.3.7 문자열 결합(CONCAT)**

- 여러개의 문자열을 연결해 하나의 문자열로 반환하는 함수이며 인자 개수 제한이 없습니다.
- 숫자타입을 넘기면 자동으로 문자열 타입으로 변환해 연결합니다.
    - 의도된 타입변환이 아니라면 명시적으로 CAST()함수를 이용해 타입을 문자열로 변환하는 편이 안전합니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/66a63da5-7d4e-4c8f-870e-286144c56cf2)


- `CONCAT_WS()`라는것도 있는데 이는 연결할 때 구분자를 넣어줍니다. (첫번째 인자를 구분자 문자로 인식)
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/5178326a-ec4f-478d-b262-2937e4bfeb2a)

    
<br>

**11.3.3.8 GROUP BY 문자열 결합(GROUP_CONCAT)**

- COUNT(), MAX(), MIN(), AVG()같은 그룹 함수(혹은 집합 함수, 여러 레코드의 값을 병합해 하나의 값을 만들어내는 함수) 중 하나 입니다.
- 주로 GROUP BY와 함께 사용하며, GROUP BY가 없는 SQL에서 사용하면 단 하나의 결과값만 만듭니다.
- **GROUP_CONCAT() 함수는**
    - **값들을 먼저 정렬한 후 연결하거나**
    - **각 값의 구분자 설정도 가능하며**
    - **여러 값 중 중복을 제거하고 연결하는 것도 가능하므로 유용합니다.**

```sql
# 기본적 사용, 모든 레코드의 dept_no 칼럼을 기본 구분자(,)로 연결한 값 반환
SELECT GROUP_CONCAT(dept_no) 
FROM departments;
+----------------------------------------------+
| GROUP_CONCAT(dept_no)                        |
+----------------------------------------------+
| d009,d005,d002,d003,d001,d004,d006,d008,d007 |
+----------------------------------------------+

# 구분자를 |로 변경
SELECT GROUP_CONCAT(dept_no SEPARATOR '|')
FROM departments;
+----------------------------------------------+
| GROUP_CONCAT(dept_no SEPARATOR '|')          |
+----------------------------------------------+
| d009|d005|d002|d003|d001|d004|d006|d008|d007 |
+----------------------------------------------+

# dpet_emp 테이블에서 emp_no 역순으로 정렬해 dept_no 칼럼의 값을 가져옴
# 내부에 사용된 ORDER BY는 전체적으로 설정된 ORDER BY와 무관하게 처리됨
SELECT GROUP_CONCAT(dept_no ORDER BY emp_no DESC)
FROM dept_emp
WHERE emp_no BETWEEN 100001 and 100003;
+--------------------------------------------+
| GROUP_CONCAT(dept_no ORDER BY emp_no DESC) |
+--------------------------------------------+
| d005,d008,d008,d005                        |
+--------------------------------------------+

# 위와 동일하지만, 중복된 dept_no값을 제거하고 가져옴
SELECT GROUP_CONCAT(DISTINCT dept_no ORDER BY emp_no DESC)
FROM dept_emp
WHERE emp_no BETWEEN 100001 and 100003;
+-----------------------------------------------------+
| GROUP_CONCAT(DISTINCT dept_no ORDER BY emp_no DESC) |
+-----------------------------------------------------+
| d008,d005                                           |
+-----------------------------------------------------+
```

- GROUP_CONCAT()은 지정한 칼럼의 값을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용합니다.
    - 시스템 변수에 지정된 크기를 초과하면 경고 메시지를 출력함
- MySQL 클라이언트, TOAD, SQLyog같은 GUI 도구를 이용해 실행하면 단순 경고지만, **JDBC로 실행될 때는 경고가 아니라 에러로 취급되어 쿼리가 실패하기에 주의해야 합니다.**
- group_concat_max_len 시스템 변수로 조정할 수 있습니다.(기본값은 1KB)
- mysql 8.0부터는 GROUP BY의 그룹별로 개수를 제한하거나 래터릴 조인, 윈도우 함수를 이용할 수 있습니다.
    
    ```sql
    -- // 윈도우 함수를 이용해 최대 5개 부서만 GROUP_CONCAT 실행
    SELECT GROUP_CONCAT(dept_no ORDER BY dept_name DESC)
    FROM (
           SELECT *, RANK() OVER (ORDER BY dept_no) AS rnk
           FROM departments
         ) as x
    WHERE rnk <= 5;
    +-----------------------------------------------+
    | GROUP_CONCAT(dept_no ORDER BY dept_name DESC) |
    +-----------------------------------------------+
    | d004,d001,d003,d002,d005                      |
    +-----------------------------------------------+
    
    -- // 래터럴 조인을 이용해 부서별로 10명씩만 GROUP_CONCAT 실행
    SELECT d.dept_no, GROUP_CONCAT(de2.emp_no)
    FROM departments d
    LEFT JOIN LATERAL (SELECT de.dept_no, de.emp_no
                       FROM dept_emp de
                       WHERE de.dept_no=d.dept_no
                       ORDER BY de.emp_no ASC LIMIT 10) de2 ON de2.dept_no=d.dept_no
    GROUP BY d.dept_no;
    +---------+-------------------------------------------------------------+
    | dept_no | GROUP_CONCAT(de2.emp_no)                                    |
    +---------+-------------------------------------------------------------+
    | d001    | 10017,10055,10058,10108,10140,10175,10208,10228,10239,10259 |
    | d002    | 10042,10050,10059,10080,10132,10144,10146,10147,10165,10173 |
    | d003    | 10005,10013,10036,10039,10054,10071,10077,10080,10086,10100 |
    | d004    | 10003,10004,10010,10018,10020,10024,10026,10029,10030,10032 |
    | d005    | 10001,10006,10008,10012,10014,10018,10021,10022,10023,10025 |
    | d006    | 10009,10010,10029,10033,10067,10073,10111,10124,10138,10152 |
    | d007    | 10002,10016,10034,10041,10050,10053,10060,10061,10068,10087 |
    | d008    | 10007,10015,10019,10040,10046,10052,10064,10070,10082,10094 |
    | d009    | 10011,10038,10049,10060,10088,10098,10112,10115,10126,10128 |
    +---------+-------------------------------------------------------------+
    ```
    

---

<br>

**11.3.3.9 값의 비교와 대체(CASE WHEN ... THEN ... END)**

- 프로그래밍 언어의 SWITCH와 같은 역할을 합니다.
- 반드시 CASE로 시작하고 END로 끝나야 하고, 사이의 WHEN, THEN은 필요한 만큼 반복해 사용할 수 있습니다.
- 크게 2가지 방식으로 사용될 수 있습니다.
    
    ```sql
    
    SELECT emp_no, first_name,
    			 CASE gender WHEN 'M' THEN 'Man'
    			             WHEN 'F' THEN 'Woman'
    			             ELSE 'Unknown' END AS gender
    FROM employees
    LIMIT 10;
    ```
    
    - 동등 연산자(=)로 비교할 수 있을 때 비교하고자 하는 칼럼이나 표현식을 CASE, WHEN 키워드 사이에 두고, 비교 기준값을 WHEN 뒤에 입력해 사용하는 방식 입니다.
    - 일반적인 프로그래밍 언어의 SWITCH 문법과 같은 방식으로 사용합니다.
    
    ```sql
    SELECT emp_no, first_name,
    		  CASE WHEN hire_date<'1995-01-01' THEN 'Old'
    	         ELSE 'New' END AS employee_type
    FROM employees
    LIMIT 10;
    
    ```
    
    - 두 비교 대상 값의 동등 비교가 아니라 크다, 작다 비교와 같이 표현식으로 비교할 때 사용하는 방식
    - CASE, WHEN 사이에 아무것도 입력하지 않고, WHEN 절에 불리언 값을 반환할 수 있는 표현식을 적어주면 됩니다.

- CASE WHEN 구문에서 반드시 CASE WHEN절이 일치해야 THEN이하의 표현식이 실행됩니다.
    
    ```sql
    # 모든 사원의 가장 최근 급여를 조회하는 쿼리
    SELECT de.dept_no, e.first_name, e.gender,
                   (SELECT s.salary FROM salaries s
                   WHERE s.emp_no=e.emp_no
                   ORDER BY from_date DESC LIMIT 1) AS last_salary
    FROM dept_emp de, employees e
    WHERE e.emp_no=de.emp_no
    		AND de.dept_no='d001';
    ```
    
    - 위 조건에서 여자라면 최종 급여 정보를, 남자라면 이름만 필요한 경우에서 굳이 남자인 경우에 salaries 테이블을 조회할 필요가 없습니다.
    - 따라서 CASE WHEN으로 필요한 경우만 서브쿼리를 실행할 수 있게 합니다.
    
    ```sql
    SELECT de.dept_no, e.first_name, e.gender,
                   CASE WHEN e.gender='F' THEN
                            (SELECT s.salary FROM salaries s
                             WHERE s.emp_no=e.emp_no
                             ORDER BY from_date DESC LIMIT 1)
                        ELSE 0 END AS last_salary
    FROM dept_emp de, employees e
    WHERE e.emp_no=de.emp_no
    		AND de.dept_no='d001';
    
    ```
    
    - 덕분에 남자 사원의 수 (1만 2천번) 만큼 서브쿼리의 실행 횟수를 줄일 수 있습니다.

---

<br>

**11.3.3.10 타입의 변환(CAST, CONVERT)**

- prepared statment를 제외하면 SQL은 텍스트(문자열) 기반으로 작동합니다.
    - prepared statement는 미리 준비된 문장으로 쿼리실행계획 분석과 컴파일이 완료되어 DBMS의 캐시에 준비된 쿼리를 사용한다는 의미입니다.
- SQL에 모든 입력값은 문자열처럼 취급합니다.
- 명시적인 타입 변환이 필요하다면 사용할 수 있습니다.
    - CONVERT()는 함수의 인자 사용 규칙만 조금 다름

- `CAST() 함수`
    - 변환 할 수 있는 데이터 타입
        - `DATE`, `TIME`, `DATETIME`, `BINARY`, `CHAR`, `DECIMAL`, `SIGNED` `INTEGER`, `UNSIGNED INTEGER`
    - 하나의 인자를 받고 하나의 인자는 두 부분으로 나뉘어 첫번째에 타입을 변환할 값, 표현식이 들어가고 나머지는 변환하고자 하는 데이터 타입을 명시합니다.
        
        ```sql
        SELECT CAST('1234' AS SIGNED INTEGER) AS converted_integer;
        SELECT CAST('2000-01-01' AS DATE) AS converted_date;
        ```
        
        문자열 → 숫자, 날짜는 자동으로 해주는 경우가 많지만 SIGNED, UNSIGNED와 같이 부호 여부를 포함하는 정숫값의 경우는 그렇지 않을때가 많습니다.
        
    - 명시적인 타입 변환이 필요한 경우
        
        ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/a5bb7829-6255-4e5d-9ae0-ef5ac7cf3ed4)

        

- `CONVERT() 함수`
    - 타입 변환 용도 및 문자열의 문자 집합을 변환하는 용도 2가지로 사용 가능
        
        ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/ce97f785-b778-4c53-a29d-ae84af3db221)

        
        문자 집합 변환의 경우 하나의 인자만 받아들이지만 두 가지 부분으로 나뉘고 사이에 USING 키워드를 명시해야 합니다.
        (값 or 표현식, 문자 집합)
        

---

<br>

**11.3.3.11 이진값과 16진수 문자열(Hex String) 변(HEX, UNHEX)**

- HEX()는 이진값을 사람이 읽을 수 있는(Human readable) 형태의 16진수의 문자열(Hex String)으로 변환합니다.
- UNHEX()는 16진수의 문자열(Hex String)을 읽어서 이진값으로 변환하는 함수입니다.
    - 이진값은 사람이 읽을 수 있는 형태가 아니라 바이너리 값임

---

<br>

**11.3.3.12 암호화 및 해시 함수(MD5, SHA, SHA2)**

- MD5, SHA는 비대칭형 암호화 알고리즘 이며 전달한 문자열을 각각 지정된 비트 수의 해시 값을 만들어내는 함수 입니다.
    - `SHA()`는 SHA-1 암호화 알고리즘을 사용하고 결과로 160비트 해시값을 반환
    - `SHA2()`는 224비트부터 512비트 암호화 알고리즘을 사용해 생성된 해시값을 반환
    - `MD5()` 함수는 Message Digest 알고리즘을 이용해 128비트 해시값을 반환

- SHA, MD5 두 함수의 출력 값은 16진수 문자열 형태기 때문에 저장하기 위해선 각각 2배의 공간이 필요합니다. (1바이트 = 8비트, 16진수 숫자 하나 = 4비트, 따라서 2개 필요)
- SHA2 함수는 사용된 인자 값에 따라 출력되는 해시 값의 길이가 달라지므로 사용된 인자의 두 배가 필요합니다.
- 따라서 암호화된 값을 저장해 두기 위해 MD5() 함수는 `CHAR(32)`, SHA() 함수는 `CHAR(40)`의 타입을 필요

```sql
SELECT MD5('abc');
+----------------------------------+
| MD5('abc')                       |
+----------------------------------+
| 900150983cd24fb0d6963f7d28e17f72 |
+----------------------------------+

SELECT SHA('abc');
+------------------------------------------+
| SHA('abc')                               |
+------------------------------------------+
| a9993e364706816aba3e25717850c26c9cd0d89d |
+------------------------------------------+

# 256 / 8 * 2 = CHAR(64)가 필요함
SELECT SHA2('abc', 256);
+------------------------------------------------------------------+
| SHA2('abc', 256)                                                 |
+------------------------------------------------------------------+
| ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad |
+------------------------------------------------------------------+
```

- 저장 공간을 원래 크기(16, 20 byte)로 줄이고 싶다면 CHAR, VARCHAR가 아닌 BINARY, VARBINARY 형태의 타입에 저장하면 됩니다.
- MD5, SHA함수의 결과를 UNHEX() 함수를 이용해 이진값으로 변환하여 저장하면 됩니다.
    
    ```sql
    CREATE TABLE tab_binary (
    	col_md5 BINARY(16),
      col_sha BINARY(20),
      col_sha2_256 BINARY(32)
    );
    
    INSERT INTO tab_binary VALUES
              (UNHEX(MD5('abc')), UNHEX(SHA('abc')), UNHEX(SHA2('abc',256)));
    
    SELECT HEX(col_md5), HEX(col_sha), HEX(col_sha2_256) FROM tab_binary;
    +----------------------------------+------------------------------------------+------------------------------------------------------------------+
    | HEX(col_md5)                     | HEX(col_sha)                             | HEX(col_sha2_256)                                                |
    +----------------------------------+------------------------------------------+------------------------------------------------------------------+
    | 900150983CD24FB0D6963F7D28E17F72 | A9993E364706816ABA3E25717850C26C9CD0D89D | BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD |
    +----------------------------------+------------------------------------------+------------------------------------------------------------------+
    ```
    
- MD5(), SHA(), SHA2()는 모두 비대칭형 암호화 알고리즘 입니다. 이들의 결과값은 중복 가능성이 매우 낮기에 길이가 긴 데이터의 크기를 줄여 인덱싱(해시)하는 용도로 사용됩니다.
- 아래 예시와 같이 함수 기반 인덱스를 만들어 사용할 수 있습니다
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/fb8c34d4-3d58-470e-8e04-a49106ba3eb8)

    

---

<br>

**11.3.3.13 처리 대기(SLEEP)**

- 프로그래밍 언어, 쉘 스크립트 에서의 sleep 기능을 수행합니다.
- SQL의 개발이나 디버깅 용도로 잠깐 대기할때 유용한 함수입니다.
- 인자를 초 단위로 받고, 특별한 처리나 반환은 없습니다.

```sql
# 검색하는 레코드의 수 마다 1.5초동안 대기합니다.
SELECT SLEEP(1.5)
FROM employees
WHERE emp_no BETWEEN 10001 AND 10010;
```

---

<br>

**11.3.3.14 벤치마크(BENCHMARK)**

- BENCHMARK()함수는 디버깅이나 간단한 함수의 성능 테스트용으로 유용한 함수 입니다.
- 2개의 인자를 필요하고 각각 반복할 횟수, 반복할 표현식입니다.
    - 다만 두번째 인자의 경우 반드시 스칼라값(하나의 칼럼을 가진 하나의 레코드)이어야 합니다.
- 반환값은 중요하지 않고, 지정된 횟수만큼 반복 실행 시간이 얼마만큼 소요됐는지가 중요합니다.
    
    ```sql
    SELECT BENCHMARK(10000000, (SELECT COUNT(*) FROM salaries));
    +------------------------------------------------------+
    | BENCHMARK(10000000, (SELECT COUNT(*) FROM salaries)) |
    +------------------------------------------------------+
    |                                                    0 |
    +------------------------------------------------------+
    1 row in set (0.46 sec)
    ```
    
- 하지만 벤치마크로 10번 실행하는 것과 직접 10번 실행하는것의 차이가 있다는걸 주의해야 합니다.
    - SQL 클라이언트 도구로 10번 실행하면 매번 쿼리의 파싱, 최적화, 테이블 잠금, 네트워크 비용 등이 소모되는데 벤치마크는 단 한 번의 비용만 소요됩니다.
    - 벤치마크는 한 번의 요청으로 표현식이 10번 실행되므로 이미 할당받은 메모리 자원까지 공유하고 메모리 할당도 클라이언트 요청보다 1/10번 밖에 일어나지 않습니다.
- 따라서 벤치마크는 두 개의 동일 기능을 상대적으로 비교 분석하는 용도로 사용할 것을 권장합니다.

---

<br>

**11.3.3.15 IP 주소 변환(INET_ATON, INET_NTOA)**

- IP 주소는 4바이트의 부호 없는 정수 입니다.
- `‘.’`으로 구분하여 IP 정보를 VARCHAR(15)에 저장하면 더 많은 저장공간을 필요로 하고 IP 주소 자체의 클래스를 구분하기 어렵습니다.
- MySQL에선 INET_ATON(), INET_NTOA()를 통해 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장할 수 있게 제공합니다.
    - INET_ATON()는 문자열 IPv4 → 정수형 변환 함수
    - INET_NTOA()는 정수형 IPv4 → 문자열 IPv4로 변환
    - 추가로 INET6로 시작하는 함수를 사용하면 IPv6주소 및 IPv4주소를 모두 BINARY 타입으로 변환하거나 역변환 합니다.

```sql
SELECT HEX(INET6_ATON('fdfe::5a55:caff:fefa:9089'));
+----------------------------------------------+
| HEX(INET6_ATON('fdfe::5a55:caff:fefa:9089')) |
+----------------------------------------------+
| FDFE0000000000005A55CAFFFEFA9089             |
+----------------------------------------------+

SELECT HEX(INET6_ATON('10.0.5.9'));
+-----------------------------+
| HEX(INET6_ATON('10.0.5.9')) |
+-----------------------------+
| 0A000509                    |
+-----------------------------+

SELECT INET6_NTOA(UNHEX('FDFE0000000000005A55CAFFFEFA9089'));
+-------------------------------------------------------+
| INET6_NTOA(UNHEX('FDFE0000000000005A55CAFFFEFA9089')) |
+-------------------------------------------------------+
| fdfe::5a55:caff:fefa:9089                             |
+-------------------------------------------------------+

SELECT INET6_NTOA(UNHEX('0A000509'));
+-------------------------------+
| INET6_NTOA(UNHEX('0A000509')) |
+-------------------------------+
| 10.0.5.9                      |
+-------------------------------+
```

- INET6로 시작하는 함수를 이용해 변환된 주소들을 저장하려면 바이너리 값을 저장할 수 있는 BINARY, VARBINARY 타입을 사용해야 합니다.
- IPv4라면 BINARY(4), IPv6라면 BINARY(16)
- 둘 다 저장해야 한다면 VARBINARY(16)을 권장합니다.

---

<br>

**11.3.3.16 JSON 포맷(JSON_PRETTY)**

- JSON_PRETTY()는 JSON 칼럼의 값을 읽기 쉬운 포맷으로 변환해줍니다.

```sql
SELECT doc FROM employee_docs WHERE emp_no=10005;
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| doc                                                                                                                                                                                                                                                                                                   |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| {"emp_no": 10005, "gender": "M", "salaries": [{"salary": 91453, "to_date": "2001-09-09", "from_date": "2000-09-09"}, {"salary": 94692, "to_date": "9999-01-01", "from_date": "2001-09-09"}], "hire_date": "1989-09-12", "last_name": "Maliniak", "birth_date": "1955-01-21", "first_name": "Kyoichi"} |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

SELECT JSON_PRETTY(doc) FROM employee_docs WHERE emp_no=10005;
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| JSON_PRETTY(doc)                                                                                                                                                                                                                                                                                                                                                                  |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| {
  "emp_no": 10005,
  "gender": "M",
  "salaries": [
    {
      "salary": 91453,
      "to_date": "2001-09-09",
      "from_date": "2000-09-09"
    },
    {
      "salary": 94692,
      "to_date": "9999-01-01",
      "from_date": "2001-09-09"
    }
  ],
  "hire_date": "1989-09-12",
  "last_name": "Maliniak",
  "birth_date": "1955-01-21",
  "first_name": "Kyoichi"
} |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
```

---

<br>

**11.3.3.17 JSON 필드 크기(JSON_STORAGE_SIZE)**

- mysql은 텍스트 기반인 JSON을 실제 디스크에 저장할때는 BSON(Binary JSON) 포맷을 사용합니다.
- 다만 BSON 변환시 저장 공간의 크기가 얼마다 될지 예측하기 어려우므로 해당 함수를 통해 반환되는 바이트값이 얼마인지 확인할 수 있습니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/c68a5412-47af-460d-bf28-8cbadb940db1)


- JSON_STORAGE_FREE()도 자주 사용될 수 있음(15.7.2절)

---

<br>

**11.3.3.18 JSON 필드 추출(JSON_EXTRACT)**

- JSON 도큐먼트에서 특정 필드의 값을 가져올 수 있습니다.
- 2개인자가 필요하며 각각 JSON 데이터가 저장된 칼럼 or JSON 도큐먼트, 가져오고자 하는 필드의 JSON path를 명시합니다.

```sql
SELECT emp_no, JSON_EXTRACT(doc, "$.first_name") FROM employee_docs;
+--------+-----------------------------------+
| emp_no | JSON_EXTRACT(doc, "$.first_name") |
+--------+-----------------------------------+
|  10001 | "Georgi"                          |
|  10002 | "Bezalel"                         |
|  10003 | "Parto"                           |
|  10004 | "Chirstian"                       |
|  10005 | "Kyoichi"                         |
+--------+-----------------------------------+

# 결과에서 쌍따옴표 제거
SELECT emp_no, JSON_UNQUOTE(JSON_EXTRACT(doc, "$.first_name")) FROM employee_docs;
+--------+-------------------------------------------------+
| emp_no | JSON_UNQUOTE(JSON_EXTRACT(doc, "$.first_name")) |
+--------+-------------------------------------------------+
|  10001 | Georgi                                          |
|  10002 | Bezalel                                         |
|  10003 | Parto                                           |
|  10004 | Chirstian                                       |
|  10005 | Kyoichi                                         |
+--------+-------------------------------------------------+

# MySQL에서 제공하는 연산자로 간편하게 사용 할 수 있음
SELECT emp_no, doc -> "$.first_name" FROM employee_docs;
+--------+-----------------------+
| emp_no | doc -> "$.first_name" |
+--------+-----------------------+
|  10001 | "Georgi"              |
|  10002 | "Bezalel"             |
|  10003 | "Parto"               |
|  10004 | "Chirstian"           |
|  10005 | "Kyoichi"             |
+--------+-----------------------+

SELECT emp_no, doc ->> "$.first_name" FROM employee_docs;
+--------+------------------------+
| emp_no | doc ->> "$.first_name" |
+--------+------------------------+
|  10001 | Georgi                 |
|  10002 | Bezalel                |
|  10003 | Parto                  |
|  10004 | Chirstian              |
|  10005 | Kyoichi                |
+--------+------------------------+
```

---

<br>

**11.3.3.19 JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)**

- JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 가지고 있는지 확인하는 함수 입니다.

```sql
SELECT emp_no FROM employee_docs
    WHERE JSON_CONTAINS(doc, '{"first_name":"Chirstian"}');
+--------+
| emp_no |
+--------+
|  10004 |
+--------+

SELECT emp_no FROM employee_docs
    WHERE JSON_CONTAINS(doc, '"Chirstian"', '$.first_name');
+--------+
| emp_no |
+--------+
|  10004 |
+--------+
```

- 첫 번째 인자는 JSON 데이터를 저장하고 있는 칼럼이나 JSON 도큐먼트고
- 두 번째 인자는 JSON 오브젝트(도큐먼트 또는 필드 값)을 사용합니다.
- 세 번째 인자는 선택사항으로 JSON 경로를 명시하면 해당 경로에 JSON 오브젝트가 존재하는 여부를 체크합니다.

---

<br>

**11.3.3.20 JSON 오브젝트 생성(JSON_OBJECT)**

- RDBMS 칼럼의 값을 이용해 JSON 오브젝트를 생성하는 함수 입니다.

```sql
SELECT 
JSON_OBJECT("empNo", emp_no,
            "salary", salary,
            "fromDate", from_date,
            "toDate", to_date) AS as_json
FROM salaries LIMIT 3;

+-------------------------------------------------------------------------------------+
| as_json                                                                             |
+-------------------------------------------------------------------------------------+
| {"empNo": 10001, "salary": 60117, "toDate": "1987-06-26", "fromDate": "1986-06-26"} |
| {"empNo": 10001, "salary": 62102, "toDate": "1988-06-25", "fromDate": "1987-06-26"} |
| {"empNo": 10001, "salary": 66074, "toDate": "1989-06-25", "fromDate": "1988-06-25"} |
+-------------------------------------------------------------------------------------+
```

---

<br>

**11.3.3.21 JSON 칼럼으로 집계(JSON_OBJECTAGG & JSON_ARRAYAGG)**

- 두 함수는 GROUP BY 절과 함께 사용되는 집계함수로 RDBMS 칼럼의 값들을 모아 JSON 배열, 도큐먼트를 생성합니다.

```sql
SELECT dept_no, JSON_OBJECTAGG(emp_no, from_date) AS agg_manager
FROM dept_manager
WHERE dept_no IN ('d001','d002','d003')
GROUP BY dept_no;

+---------+--------------------------------------------------+
| dept_no | agg_manager                                      |
+---------+--------------------------------------------------+
| d001    | {"110022": "1985-01-01", "110039": "1991-10-01"} |
| d002    | {"110085": "1985-01-01", "110114": "1989-12-17"} |
| d003    | {"110183": "1985-01-01", "110228": "1992-03-21"} |
+---------+--------------------------------------------------+

SELECT dept_no, JSON_ARRAYAGG(emp_no) as agg_manager
FROM dept_manager
WHERE dept_no IN ('d001','d002','d003')
GROUP BY dept_no;
+---------+------------------+
| dept_no | agg_manager      |
+---------+------------------+
| d001    | [110022, 110039] |
| d002    | [110085, 110114] |
| d003    | [110183, 110228] |
+---------+------------------+
```

- JSON_OBEJCTTAG()는 Key, Value 쌍으로 지정해야 하기에 2개의 인자가 필요합니다. 키-밸류 쌍을 통해 JSON 도큐먼트를 만들어 반환합니다.
- JSON_ARRAYAGG()는 하나의 인자를 받아 주어진 RDBMS 칼럼의 값을 이용해 JSON 배열을 만들어 반환합니다.

---

<br>

**11.3.3.22 JSON 데이터를 테이블로 변환(JSON_TABLE)**

- JSON 데이터의 값들을 모아서 RDBMS 테이블을 만들어 반환합니다.
- JSON_TABLE() 함수가 만들어 반환하는 테이블의 레코드 건수는 원본 테이블(함수 직전에 명시된 테이블)과 동일한 레코드 건수를 가집니다.

```sql
SELECT e2.emp_no, e2.first_name, e2.gender
FROM employee_docs e1,
         JSON_TABLE(doc, "$" COLUMNS (emp_no INT PATH "$.emp_no",
                                      gender CHAR(1) PATH "$.gender",
                                      first_name VARCHAR(20) PATH "$.first_name") 
                   ) AS e2 
WHERE e1.emp_no IN (10001, 10002);

+--------+------------+--------+
| emp_no | first_name | gender |
+--------+------------+--------+
|  10001 | Georgi     | M      |
|  10002 | Bezalel    | F      |
+--------+------------+--------+
```

- 항상 내부 임시 테이블을 이용하기 때문에 임시 테이블에 레코드가 많이 저장되지 않게 주의해야 합니다.
    
    ```sql
    EXPLAIN
    SELECT e2.emp_no, e2.first_name, e2.gender
    FROM employee_docs e1,
             JSON_TABLE(doc, "$" COLUMNS (emp_no INT PATH "$.emp_no",
                                          gender CHAR(1) PATH "$.gender",
                                          first_name VARCHAR(20) PATH "$.first_name") 
                       ) AS e2 
    WHERE e1.emp_no IN (10001, 10002);
    
    +----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+---------------------------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                       |
    +----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+---------------------------------------------+
    |  1 | SIMPLE      | e1    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    2 |   100.00 | Using where                                 |
    |  1 | SIMPLE      | e2    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |    2 |   100.00 | Table function: json_table; Using temporary |
    +----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+---------------------------------------------+
    ```
