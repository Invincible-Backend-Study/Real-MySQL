# 📌 9장: 옵티마이저와 힌트

MySQL에선 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 `통계 정보`를 참조하며, 기본 데이터를 비교해 실행 게획을 수립하는 작업이 필요합니다.

MySQL 서버를 포함한 대부분의 DBMS는 옵티마이저가 이런 기능을 담당합니다.

→ EXPLAIN 명령어는 쿼리 실행 계획을 보여주는데 실행 계획의 내용을 제대로 이해하기 위해선 MySQL 서버 옵티마이저가 실행하는 최적화에 대한 지식을 알고 있어야 합니다.

<br><br><br>

## ✅ 9.1 개요

옵티마이저는 가장 복잡하고, 만들어내는 실행 계획을 이해하는건 어려운 일입니다.

다만 이를 이해해야 실행 계획에서 불합리한 부분을 찾고 더 최적화된 방법으로 실행 계획을 수립할 수 있도록 유도할 수 있습니다.

<br><br>

### 9.1.1 쿼리 실행 절차

MySQL 서버에서 쿼리 실행 과정은 3단계로 나눌 수 있습니다.

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리 한다. 
(Parse Tree)
2. SQL의 파싱 정보(Parse Tree)를 확인하면서 어떤 테이블 부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

`1단계`를 SQL Parsing이라고 하며, MySQL 서버의 SQL Parser라는 모듈로 처리합니다. SQL 문장의 문법적인 오류를 해당 단게에서 거르며, 결과물로 SQL Parse Tree가 만들어집니다. **MySQL 서버는 SQL Parse Tree를 이용해 쿼리를 실행합니다.**

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/a73eb07a-bc49-426b-b088-f1802e985c3c)


https://www.cs.emory.edu/~cheung/Courses/554/Syllabus/5-query-opt/intro-parsing.html

`2단계`에선 SQL 파스 트리를 참조하며 다음 내용을 처리합니다.

- 불필요한 조건 제거 및 복잡한 연산의 단순화
- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

외에도 수많은 처리를 하지만 위 작업이 대표적입니다. 2단계는 `최적화 및 실행 계획 수립` 단계에 해당되며 MySQL 서버의 옵티마이저가 담당합니다. 2단계의 산출물은 `실행 계획`이 됩니다.

`3단계`는 수립된 실행계획 대로 스토리지 엔진에 레코드를 읽어오도록 요청하고 MySQL 엔진에선 받은 레코드를 조인, 정렬하는 작업을 합니다.

→ 1, 2단계는 MySQL 엔진에서 처리하며 3단계는 MySQL 엔진 및 스토리지 엔진이 동시에 참여해 처리합니다.

<br><br>

### 9.1.2 옵티마이저의 종류

옵티마이저 == DB서버의 두뇌

옵티마이저는 크게 2가지 최적화 방식으로 나눌 수 있습니다.

1. **비용 기반 최적화 (Cost-based optimizer, CBO) → MySQL이 사용하는 방식**
    - 대부분의 DBMS가 선택하고 있음.
    - 쿼리 처리 위한 여러가지 가능한 방법을 만듭니다.
    - 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계정보(레코드 건수, 선택도 등)를 이용해 실행 계획별 비용을 산출합니다.
    - 각 실행 방법중에서 최소 비용이 되는 방식을 선택해 쿼리를 실행합니다.
2. **규칙 기반 최적화 (Rule-based optimizer, RBO)**
    - 초기 버전의 오라클 DBMS에서 많이 사용함
    - 대상 테이블의 **레코드 건수, 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립**함
    - 위와 같은 통계정보를 고려하지 않으므로 같은 쿼리에 대해선 거의 항상 같은 실행 방법을 만듭니다.
    - 오래전부터 사용해오지 않던 방식
    
<br><br><br>

## ✅ 9.2 기본 데이터 처리

MySQL 서버 포함 모든 RDBMS는 데이터 정렬, 그루핑 등 기본 데이터 가공 기능을 가지고 있지만, 동일한 결과물에 비해 과정은 천차만별입니다.

9.2절은 그 중에서 MySQL 서버가 어떤 알고리즘을 사용하는지 살펴봅니다.

<br><br>

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔은 인덱스 사용없이 테이블의 데이터를 처음부터 끝까지 읽어 요청 작업을 처리하는것을 의미합니다. MySQL 옵티마이저는 다음 조건과 일치하면 풀 테이블 스캔을 선택합니다.

- 테이블의 레코드 건수가 너무 작아, 인덱스를 거치는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
(일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리이지만, 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 **많은 Disk I/O가 필요**합니다. 따라서 DBMS는 풀 테이블 스캔시 한꺼번에 여러 개의 블록, 페이지를 읽어오는 기능이 있습니다. 다만, **MySQL은 몇 개씩 페이지를 읽어올지 설정하는 시스템 변수는 없습니다.**

InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 다음과 같이 동작합니다.

- 백그라운드 스레드에 의해 Read Ahead 작업이 자동으로 시작됨
    - 어떤 영역의 데이터가 앞으로 필요할 것을 예측해 요청이 오기전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 둠
    - `innodb_read_ahead_threshold` 시스템 변수를 통해 Read Ahead 작업의 임계값을 설정합니다.
    (디폴트 설정으로 충분하지만, 데이터 웨어하우스 용으로 MySQL을 사용하면 더 낮은 값을 설정해 더 빨리 시작되도록 유도하는것도 좋음)
- 풀 테이블 스캔은 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘깁니다.
- 백그라운드 스레드는 한 번에 4개씩 또는 8개씩 페이지를 읽으며 점차 수를 증가시키는데, 최대 64개의 데이터 페이지까지 읽어 버퍼 풀에 저장해둡니다.
- 덕분에 포그라운드 스레드는 버퍼풀에 있는 데이터를 가져다 사용하기만 하면 되므로 쿼리 처리가 빨라집니다.

Read Ahead는 풀 인덱스 스캔에서도 동일하게 사용됩니다.

```sql
# 아무런 조건 없이 레코드 건수를 조회함
SELECT COUNT(*) FROM employees;

# 레코드의 모든 컬럼을 요구함
SELECT * FROM employees;
```

첫 번째 쿼리의 경우 레코드 건수만 필요하므로 풀 인덱스 스캔을 사용합니다. (보통 테이블의 2~3개 칼럼만으로 인덱스가 구성되므로 디스크 읽기 횟수를 줄임)

두 번째 쿼리의 경우 모든 칼럼을 요구하므로 풀 테이블 스캔을 하게 됩니다.

<br><br>

### 9.2.2 병렬 처리

- 8.0버전부터는 MySQL 서버에서도 하나의 작업에 대한 병렬 처리가 가능해졌습니다.
    
    → 8.0 이전에는 각 스레드가 각자의 쿼리를 처리하는게 가능했지만, 하나의 작업에 대한 여러 스레드의 병렬처리는 8.0부터 도입
    
- `innodb_parallel_read_threads`라는 시스템 변수를 이용해 하나의 쿼리에 대해 최대 몇 개의 스레드를 이용해 처리할지 변경할 수 있음
- 다만 아직 MySQL 서버에선 쿼리를 여러 개의 스레드를 이용해 병렬로 처리하게 하는 힌트나 옵션은 없습니다.
- 8.0버전에선 WHERE조건 없는 단순히 테이블의 전체 건수만 가져오는 쿼리만 병렬처리가 가능합니다.

→ 병렬 처리용 스레드 개수가 CPU 코어 개수를 넘어서는 경우 오히려 성능이 떨어질 수 있습니다.

<br><br>

### 9.2.3 ORDER BY 처리(Using filesort)

대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용됩니다. 정렬 처리 방법으로 인덱스를 이용하는 방법과 쿼리가 실행될 때 `Filesort`라는 별도 처리를 이용하는 방법으로 나뉩니다.

|  | 장점 | 단점 |
| --- | --- | --- |
| 인덱스 이용 | INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어 순서대로 읽기만 하면 되므로 매우 빠름 | INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 비용이 큼

인덱스로 인해 디스크 공간이 더 필요함

인덱스의 개수가 늘어날수록 InnoDB 버퍼풀을 이용한 메모리가 많이 필요함 |
| Filesort | 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점이 됨

정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름 | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 건수가 많아질수록 쿼리의 응답 속도가 느림 |

레코드 정렬을 항상 Filesort라는 정렬 작업을 거쳐야 하는건 아니지만, 다음과 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능합니다.

- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는것이 불가능
- GROUP BY의 결과 또는 DISTINCT 같은처리의 결과를 정렬 해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

→ 실행 계획의 Extra 칼럼에 “`Using filesort`” 메시지가 표시되는지 여부로 인덱스를 사용하지 않고 정렬처리를 수행했는지 여부를 판단할 수 있습니다.

```sql
# SALARIES 테이블에서 from_date 그룹별 카운팅을 from_date 오름차순으로 정렬하여 결과를 보여줍니다.
EXPLAIN 
SELECT from_date, count(*) 
FROM salaries 
GROUP BY from_date 
ORDER BY from_date;

+----+-------------+----------+------------+-------+-------------------+-----------+---------+------+---------+----------+----------------------------------------------+
| id | select_type | table    | partitions | type  | possible_keys     | key       | key_len | ref  | rows    | filtered | Extra                                        |
+----+-------------+----------+------------+-------+-------------------+-----------+---------+------+---------+----------+----------------------------------------------+
|  1 | SIMPLE      | salaries | NULL       | index | PRIMARY,ix_salary | ix_salary | 4       | NULL | 2838426 |   100.00 | Using index; Using temporary; Using filesort |
+----+-------------+----------+------------+-------+-------------------+-----------+---------+------+---------+----------+----------------------------------------------+
1 row in set, 1 warning (0.00 sec)
```

<br>

**소트 버퍼(Sort Buffer)**

- Sort Buffer는 MySQL이 정렬을 수행하기 위해 별도로 할당 받는 메모리 공간을 말합니다.
- 정렬이 필요한 경우에만 할당되며, 버퍼 크기는 가변적이지만 최대 사용 가능한 버퍼 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있습니다.
- 할당 받은 메모리는 쿼리 실행 완료이후 즉시 시스템으로 반납됩니다.

`정렬이 문제가 되는 이유`

- 정렬할 레코드가 소량이라면 소트 버퍼만으로 아주 빠르게 처리되지만, 레코드의  크기가 할당받은 소트 버퍼보다 큰 경우 MySQL은 레코드를 여러 조각으로 나누는데 이때 `임시저장을 위해 디스크를 사용합니다.`
    - 메모리의 소트 버퍼 정렬 수행 → 임시 결과를 디스크에 기록 → 다음 레코드 가져와 정렬 → 반복적인 디스크 임시 저장
    - 각 버퍼 크기만큼 정렬된 레코드는 다시 병합하며 정렬을 수행하는데 이를 Multi-merge라고 표현합니다. (수행된 멀티 머지 횟수는 sort_merge_passes라는 시스템 변수에 누적 집계됨)
- 결국 `버퍼를 사용하지만 디스크의 쓰기 및 읽기를 유발`하며, 레코드 건수가 많을수록 반복 작업의 횟수가 많아집니다.(버퍼의 크기를 키운다고 한들 실제 벤치마크 결과는 큰 차이가 없음)
- 소트 버퍼는 세션 메모리 영역에 해당되므로 커넥션이 많고, 정렬 작업도 많다면 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미합니다.
    - 심해지면 운영체제의 메모리 부족으로 인해 OOM-Killer가 여유 메모리 확보를 위한 프로세스 강제 종료를 하게 되는데 이때 1순위가 MySQL 서버가 될 수 있으니 주의해야 합니다.

→ 소트 버퍼를 키우면 디스크의 읽기 및 쓰기 사용량은 줄일 수 있습니다. 디스크 I/O 성능이 낮거나, MySQL 서버의 데이터가 많다면 고려해볼만 합니다. 다른 방법으로 대량 데이터의 정렬이 필요한 경우 해당 세션의 소트 버퍼만 일시적으로 늘려 쿼리를 실행하고 다시 줄이는 것도 방법이 됩니다.

<br>

**정렬 알고리즘 (Filesort시 사용됨)**

레코드 정렬시 소트 버퍼에 담는 내용에 따라 2가지 정렬 모드로 나뉩니다. (공식 명칭 아님)

1. 싱글 패스(Single-Pass)
    - 레코드 전체를 소트 버퍼에 담음
2. 투 패스(Two-Pass)
    - 정렬 기준 칼럼만 소트 버퍼에 담음

정렬 수행 쿼리가 사용하는 정렬 모드는 다음과 같은 옵티마이저 트레이스 기능으로 확인할 수 있습니다.

```sql

# 옵티마이저 트레이스 활성화
SET OPTIMIZER_TRACE="enabled=on", END_MARKERS_IN_JSON=on;
SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;

# 쿼리 실행
SELECT * FROM employees ORDER BY last_name LIMIT 100000,1;

# 트레이스 내용 확인
SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

# 결과
"filesort_information": [
              {
                "direction": "asc",
                "expression": "`employees`.`last_name`"
              }
            ] /* filesort_information */,
            "filesort_priority_queue_optimization": {
              "limit": 100001
            } /* filesort_priority_queue_optimization */,
            "filesort_execution": [
            ] /* filesort_execution */,
            "filesort_summary": {
              "memory_available": 262144,
              "key_size": 32,
              "row_size": 169,
              "max_rows_per_buffer": 1551,
              "num_rows_estimate": 300584,
              "num_rows_found": 300024,
              "num_initial_chunks_spilled_to_disk": 82,
              "peak_memory_used": 262144,
              "sort_algorithm": "std::stable_sort",
              "sort_mode": "<fixed_sort_key, packed_additional_fields>"
            } /* filesort_summary */
```

- sort_algorithm에 정렬 알고리즘 `std::stable_sort`를 확인할 수 있습니다.
- sort_mode 필드는 정렬 방식을 나타내는데 3가지 종류가 있습니다.
    1. `<sort_key, rowid>`: 정렬 키와 레코드의 Row ID만 가져와서 정렬하는 방식
    2. `<sort_key, additional_fields>`: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드 칼럼들은 고정 사이즈로 메모리 저장
    3. `<sort_key, packed_additional_fields>`: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드의 칼럼들은 가변 사이즈로 메모리 저장

→ 책에서는 1번 방식을 “투 패스” 정렬 방식이라 명명하고 2, 3번을 “싱글 패스” 정렬 방식이라 명명합니다.

→ 5.7 버전부터 3번 방식이 도입됐는데, 정렬을 위한 메모리 공간의 효율적인 사용을 위해서 추가로 도입된 방식입니다.

→ `std::stable_sort` 는 C++의 STL에서 제공하는stable_sort()함수를 사용함을 의미

<br>

**싱글 패스 정렬 방식**

Sort Buffer에 **정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행**하는 방식입니다.

```sql
SELECT emp_no, first_name, last_name FROM employees ORDER BY first_name;
```

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/9c2fad34-6962-42f3-b684-6cc6b921feb2)


- employees 테이블을 읽을 때 정렬에 필요하지 않은 last_name 칼럼까지 읽어 소트 버퍼에 담아 정렬을 수행합니다. 정렬 완료 이휴 정렬 버퍼의 내용을 그대로 클라이언트로 넘겨줍니다.

<br>

**투 패스 정렬 방식**

정렬 대상 칼럼, PK 값만 소트 버퍼에 담아 정렬을 수행하고, 정렬된 순서대로 다시 PK로 테이블을 읽어 SELECT 할 칼럼을 가져오는 정렬 방식
(싱글 패스 도입 이전부터 사용하던 방식, 8.0에서도 특정 조건에선 투 패스 정렬 방식 사용)

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/1a5e4ba6-e9ef-4f1d-b39a-51e8820473bc)


- 처음 테이블을 읽을때는 필요한 칼럼만 조회하고, 정렬이 완료되면 결과 순서대로 다시 한번 테이블을 읽어 필요한 칼럼(last_name)을 가져와 최종적으로 결과를 클라이언트에게 넘겨줍니다.
- 테이블을 두 번 읽어야 합니다.

새로운 정렬 방식인 싱글 패스는 테이블을 두 번 읽는 상황은 없지만 더 많은 소트 버퍼 공간이 필요합니다.

만약 128KB의 정렬 버퍼를 사용하면 투 패스 정렬 방식에선 대략 7,000건의 레코드를 정렬할 수 있지만, 싱글 패스는 반 정도밖에 정렬할 수 없습니다.

최신 버전에선 주로 싱글 패스 정렬 방식을 사용합니다. 하지만, 몇몇 상황에선 투 패스 정렬 방식을 사용하기도 합니다.

- 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때
- BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때

→ 투 패스는 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이고, 적은 경우에는 싱글 패스가 효율적입니다.

**→ SELECT ***과 같은 모든 칼럼 조회의 경우 `정렬 버퍼를 몇 배~몇 십배 비효율적으로 사용할 가능성이 큽니다.` 따라서 꼭 필요한 칼럼만 조회하도록 작성하는것을 권장합니다.

<br>

**정렬 처리 방법**

쿼리에 ORDER BY가 사용되면 3가지 처리 방법 중 하나로 정렬이 처리됩니다.

| 정렬 처리 방법 | 실행 계획의 Extra 칼럼 내용 |
| --- | --- |
| 인덱스를 사용한 정렬 | 별도 표기 없음 |
| 조인에서 드라이빙 테이블만 정렬 | “Using filesort” 메시지가 표시됨 |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬
(조인 이후 정렬) | “Using temporary; Using filesort” 메시지가 표시됨 |
- 드라이빙 테이블이란
    - 드라이빙 테이블은 join시에 먼저 엑세스 되는 테이블을 의미합니다.
    - 반대로 나중에 엑세스되는 테이블은 드리븐 테이블, 혹은 이너 테이블이라고 합니다.
    - 이 때 드라이빙 테이블이 될 것인지, 즉 어떤 테이블을 먼저 엑세스 할 것인지가 중요합니다.
        
        ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/18ac1ec4-46c3-4158-afc4-44cfde68c0dd)

        
        ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/a6ddbcd0-d6d4-40f0-8843-1a0f1588f8df)

        
        https://programming-workspace.tistory.com/67
        

옵티마이저는 정렬 처리를 위해 인덱스를 사용할 수 있다면 인덱스를 사용한 정렬을 활용합니다.

인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하며 정렬을 처리(Filesort) 합니다.

MySQL 옵티마이저는 정렬 대상 레코드를 최소화 하기 위해 다음 2가지 방법 중 하나를 선택합니다.

1. **조인의 드라이빙 테이블만 정렬한 후 조인을 수행**
2. **조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행**

조인 결과는 보통 배수로 불어나기에 1번 방식이 좀 더 효율적입니다.

<br>

**인덱스를 이용한 정렬**

- 인덱스를 이용한 정렬은 반드시 **ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고**(조인이 사용된 경우 드라이빙 테이블) **ORDER BY에 명시된 칼럼 순서대로 생성된 인덱스가 있어야 합니다.**
- 또한 WHERE 절에 첫 번째로 읽는 테이블 칼럼에 대한 조건이 있다면 해당 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 합니다.
- B-Tree 계열의 인덱스가 아니라 해시 인덱스, 전문 검색 인덱스 등에서는 인덱스를 사용한 정렬 사용 불가
- 여러 테이블이 조인되는 경우 Nested Loop Join에서만 이 방식을 사용할 수 있습니다.
    
    https://coding-factory.tistory.com/756
    

인덱스를 이용해 정렬이 처리되면 단순히 인덱스 순서대로 읽기만 하면 됩니다. 실제로 MySQL 엔진에서 정렬을 위한 별도의 추가 작업을 수행하지 않습니다.

```sql
# 아래 두 쿼리의 결과는 모두 동일함
select * 
from employees e, salaries s 
where s.emp_no = e.emp_no 
and e.emp_no between 100002 AND 100020 
order by e.emp_no;

select * 
from employees e, salaries s 
where s.emp_no = e.emp_no 
and e.emp_no between 100002 AND 100020 
```

어차피 클러스터링 인덱스가 정렬되어 있으므로 결과는 동일하게 나옵니다.

- 주의사항
    - 다만 특정 이유로 쿼리의 실행 계획이 조금 변경된다면 ORDER BY가 명시되지 않은 쿼리의 결과가 기대했던 순서로 가져오지 못할 수 있으므로, ORDER BY를 명시해두는 편이 좋습니다.
    - B-Tree 인덱스가 키 값으로 정렬되어 있고, Nested Loop Join이 실행되기에 인덱스 읽기 순서가 흐트러지지 않지만, **조인이 사용된 쿼리의 실행계획에 조인 버퍼(Join Buffer)가 사용되면 순서가 흐트러질 수 있기 때문에 주의해야 합니다.**

<br>

**조인의 드라이빙 테이블만 정렬**

조인이 수행되면 레코드의 건수가 배로 불어나기 때문에, 첫 번째 테이블의 레코드를 먼저 정렬하고 조인을 하는 것이 정렬의 차선책이 될 것 입니다.

이 방법으로 정렬이 처리되기 위해선 조인에서 첫 번째로 읽히는 드라이빙 테이블의 칼럼만으로 ORDER BY 절을 작성해야 합니다.

```sql
SELECT * 
FROM employees e, salaries s 
WHERE s.emp_no=e.emp_no 
AND e.emp_no BETWEEN 100002 AND 100010 
ORDER BY e.last_name;
```

위의 WHERE절의 조건 때문에 옵티마이저는 employees 테이블을 드라이빙 테이블로 선택합니다.

- WHERE 절의 검색 조건 (`e.emp_no BETWEEN 100002 AND 100010`)은 employees 테이블의 PK를 이용해 검색하면 작업량을 줄일 수 있습니다.
- 드리븐 테이블(salaries)의 조인 칼럼인 emp_no 칼럼에 인덱스가 있다.
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/5b5fa7a4-317a-48ea-ad04-03a50c37c14f)

    
- 위의 쿼리의 검색까지는 인덱스 레인지 스캔으로 처리할 수 있지만 `ORDER BY 절에 명시된 칼럼이 employees의 PK와 전혀 연관이 없으므로 인덱스를 사용한 정렬은 사용 불가`능합니다.
- **ORDER BY 절의 기준 칼럼이 드라이빙 테이블(employees)에 포함된 칼럼이므로 옵티마이저는 드라이빙 테이블만 검색해 정렬을 먼저 수행하고, 그 결과와 salaries 테이블을 조인합니다.**

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/d7be2fbc-0afd-4166-8fd7-3813cd0e4c22)

<br>

**임시 테이블을 이용한 정렬**

조인의 드라이빙 테이블만 정렬을 제외한 패턴의 쿼리에선 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거칩니다.

따라서 3가지 방법 가운데 정렬 할 레코드가 건수가 가장 많아 제일 느린 정렬 방법입니다.

```sql
EXPLAIN 
SELECT * 
FROM employees e, salaries s 
WHERE s.emp_no=e.emp_no 
	AND e.emp_no BETWEEN 100002 AND 100010 
ORDER BY s.salary;

+----+-------------+-------+------------+-------+---------------+---------+---------+--------------------+------+----------+----------------------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref                | rows | filtered | Extra                                        |
+----+-------------+-------+------------+-------+---------------+---------+---------+--------------------+------+----------+----------------------------------------------+
|  1 | SIMPLE      | e     | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL               |    9 |   100.00 | Using where; Using temporary; Using filesort |
|  1 | SIMPLE      | s     | NULL       | ref   | PRIMARY       | PRIMARY | 4       | employees.e.emp_no |    9 |   100.00 | NULL                                         |
+----+-------------+-------+------------+-------+---------------+---------+---------+--------------------+------+----------+----------------------------------------------+

```

ORDER BY절에서 드라이빙 테이블이 아닌 드리븐 테이블의 컬럼을 기준으로 정렬이 수행되어야 하므로, 반드시 조인된 데이터를 가지고 정렬할 수 밖에 없습니다.

따라서 실행계획의 `Using temporary`를 통해 조인 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 했음을 의미합니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/52718b95-2e34-4863-9725-2537987b8258)

<br>

**정렬 처리 방법의 성능 비교**

- 웹 서비스용 쿼리는 ORDER BY + LIMIT가 사용되는 경향이 있습니다.
- 다만 LIMIT가 있어도 ORDER BY, GROUP BY는 모든 레코드에 적용하고 LIMIT만큼 잘라내므로 WHERE 조건이 인덱스를 잘 활용한다 하더라도 잘못된 ORDER BY, GROUP BY때문에 쿼리가 느려지는 경우가 있습니다.

**→ 정렬이나 그루핑 작업이 느리게 작동할 수 밖에 없는 이유를 알기 위해서는 쿼리가 처리되는 방식인 스트리밍 처리와 버퍼링 처리라는 방식을 알아야 합니다.**

<br>

**스트리밍 방식**

- 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식을 의미합니다.
- 스트리밍 방식을 사용하면 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번째 레코드를 전달받습니다. 
(마지막 레코드는 언제받을지 모르지만 중요한게 아님)
- 스트리밍 방식은 처리되는 쿼리가 조회하는 레코드 양에 관계없이 빠른 응답 시간을 보장해줍니다.
    - OLTP 환경에서 유리함
    - LIMIT같이 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줌
    - `JDBC`의 경우 자체적으로 버퍼링을 합니다. MySQL은 스트리밍으로 처리해도 JDBC에서 버퍼링 되는 경우도 있음, 이는 전체 처리 시간을 줄이고 MySQL과의 통신 횟수를 줄이기 위함임

<br>

**버퍼링 방식**

- ORDER BY, GROUP BY같은 처리는 쿼리의 결과가 스트리밍 되는 것을 불가능하게 합니다.
(WHERE 조건에 해당되는 레코드를 정렬 및 그루핑 해야 하므로)
- 레코드 검색 및 후작업 시간동안 클라이언트는 기다려야 하기에 응답속도는 느려집니다.
- 여기에서 처리되는 쿼리는 결과를 모아 MySQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로부터 가져올 때까지 기다려야 합니다.
    - 따라서 LIMIT와 같은 결과 건수 제한 조건이 성능 향상에 도움되지 않음

정렬 처리 방법의 3가지 방법 중에서 인덱스를 사용한 정렬방식만 스트리밍 형태의 처리이며, 나머지는 모두 버퍼링된 후 정렬됩니다.

<br>

**조인과 함께 ORDER BY + LIMIT절이 사용될 경우 정렬 방법별 차이**

```sql
# test1레코드 100개 test2레코드 1000개, test1 1개 레코드당 test2 레코드 10개씩 존재함
SELECT * FROM tb_test1 t1, tb_test2 t2
WHERE t1.col1 = t2.col1
ORDER BY t1.col2
LIMIT 10;
```

- tb_test1이 드라이빙 테이블이 되는 경우
    
    
    | 정렬 방법 | 읽어야 할 건수 | 조인 횟수 | 정렬해야 할 대상 건수 |
    | --- | --- | --- | --- |
    | 인덱스 사용 | tb_test1: 1건
    tb_test2: 10건 | 1번 | 0건 |
    | 조인의 드라이빙 테이블만 정렬 | tb_test1: 100건
    tb_test2: 10건 | 1번 | 100건
    (tb_test1 테이블의 레코드 건수만큼 정렬 필요) |
    | 임시 테이블 사용 후 정렬 | tb_test1: 100건
    tb_test2: 1000건 | 100번
    (tb_test1 테이블의 레코드 건수만큼 조인 발생) | 1000건
    (조인된 결과 레코드 건수를 전부 정렬) |
- tb_test2가 드라이빙 테이블이 되는 경우
    
    
    | 정렬 방법 | 읽어야 할 건수 | 조인 횟수 | 정렬해야 할 대상 건수 |
    | --- | --- | --- | --- |
    | 인덱스 사용 | tb_test2: 10건
    tb_test1: 10건 | 10번 | 0건 |
    | 조인의 드라이빙 테이블만 정렬 | tb_test2: 1000건
    tb_test1: 10건 | 10번 | 1000건
    (tb_test2 테이블의 레코드 건수만큼 정렬 필요) |
    | 임시 테이블 사용 후 정렬 | tb_test2: 1000건
    tb_test1: 100건 | 1000번
    (tb_test2 테이블의 레코드 건수만큼 조인 발생) | 1000건
    (조인된 결과 레코드 건수를 전부 정렬) |

위 예시를 보면 테이블의 드라이빙 여부도 중요하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이를 발생시킵니다.

가능하면 인덱스 정렬을 사용하고, 적어도 드라이빙 테이블은 정렬되도록 사용하는편이 좋습니다.

- 참고
    
    추가로 정렬할 대상에 LIMIT 10의 조건이 있다면 MySQL 서버는 1,000개가 있어도 상위 10건만 정렬되면 즉시 반환합니다. 그러나 정렬 알고리즘의 특성상(퀵 소트, 힙 소트) 단순히 상위 10건만을 정렬한다 하더라도 더 많은 작업이 필요할 수 있습니다.
    
<br>

**정렬 관련 상태 변수**

MySQL 서버는 처리하는 주요 작업의 실행 횟수를 상태 변수로 저장합니다.

- 정렬 처리한 레코드 수
- 소트 버퍼 간의 병합 작업(멀티 머지)

등을 확인할 수 있습니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/375c8745-212e-42f9-91f2-510c1c728b6f)


- `Sort_merge_passes`: 멀티 머지 처리 횟수 의미
- `Sort_range`: 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 누적 횟수
- `Sort_scan`: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 누적 횟수
- `Sort_rows`: 지금까지 정렬한 전체 레코드 건수

<br><br>

### 9.2.4 GROUP BY 처리

- GROUP BY 또한 ORDER BY와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리 중 하나입니다.
- GROUP BY에 사용된 조건은 인덱스를 사용해 처리될 수 없으므로 HAVING절을 튜닝하려고 인덱스 생성이나 다른 방법을 고민하지 않아도 됩니다.
- GROUP BY 작업도 인덱스 사용 작업과 그렇지 못한 경우로 나뉩니다.

<br>

**인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)**

- 조인의 드라이빙 테이블에 속한 칼럼만을 이용해 그루핑 할때 GROUP BY 칼럼으로 이미 인덱스가 있다면 해당 인덱스를 차례로 읽으며 그루핑 작업을 수행하고 결과로 조인을 처리 합니다.
- Aggregation Function(집계 함수)를 사용하면 그룹값 처리를 위해 임시 테이블이 필요할수도 있음
- 인덱스 스캔을 이용했을때 쿼리 실행계획의 Extra 칼럼은 별도로 GROUP BY 관련 코멘트(Using index for group-by)나 임시 테이블 사용 또는 정렬 관련 코멘트가(Using temporary, Using filesort) 표시되지 않습니다.

<br>

**루스 인덱스 스캔을 이용하는 GROUP BY**

인덱스의 레코드를 건너뛰며 필요한 부분만 읽어서 가져오는것을 의미합니다. 이때 실행 계획의 Extra 칼럼에는 `Using index for group-by` 코멘트가 표시됩니다.

```sql
EXPLAIN 
SELECT emp_no 
FROM salaries 
WHERE from_date='1985-03-01' 
GROUP BY emp_no;
+----+-------------+----------+------------+-------+-------------------+---------+---------+------+--------+----------+---------------------------------------+
| id | select_type | table    | partitions | type  | possible_keys     | key     | key_len | ref  | rows   | filtered | Extra                                 |
+----+-------------+----------+------------+-------+-------------------+---------+---------+------+--------+----------+---------------------------------------+
|  1 | SIMPLE      | salaries | NULL       | range | PRIMARY,ix_salary | PRIMARY | 7       | NULL | 294784 |   100.00 | Using where; Using index for group-by |
+----+-------------+----------+------------+-------+-------------------+---------+---------+------+--------+----------+---------------------------------------+
```

단순 WHERE 조건만 보면 (emp_no, from_date) 인덱스를 사용해 인덱스 레인지 스캔 접근 방식을 사용할 수 없지만, 결과는 인덱스 레인지 스캔을 사용(type=range)했으며 GROUP BY또한 인덱스를 사용했다는걸 알 수 있습니다.

<br>

**MySQL 서버는 다음과 같이 쿼리를 실행합니다.**

1. (emp_no, from_date) 인덱스를 차례로 스캔하며 emp_no의 첫 번째 유일한 값(그룹 키) “10001” 찾음
2. 인덱스를 활용해 emp_no가 ‘10001’것에서 from_date값이 ‘1985-03-01’인걸 가져옴 마치 `emp_no=10001 AND from_date=’1985-03-01’` 조건으로 (emp_no, from_date)인덱스를 검색하는 것과 거의 흡사합니다.
3. (emp_no, from_date) 인덱스에서 emp_no의 그 다음 유니크한 값(그룹 키)을 가져옵니다.
4. 3번 단계에서 결과가 더 있다면 2번을 반복, 아니라면 종료

- MySQL 루스 인덱스 스캔 조건
    - 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있습니다.
    - 프리픽스 인덱스(칼럼 값의 앞쪽 일부만으로 생성된 인덱스)는 루스 인덱스 스캔을 사용할 수 없습니다.

- MySQL 루스 인덱스 스캔 성능
    - 인덱스 레인지 스캔과 달리 유니크한 값의 수가 적을수록 성능 향상됨(분포도가 좋지 않은 인덱스일수록)

- 루스 인덱스 스캔을 사용할 수 없는 쿼리 패턴
    
    ```sql
    # tb_test는 (col1, col2, col3) 인덱스 존재
    
    # MIN(), MAX()이외의 집합 함수가 사용됨, 루스 인덱스 스캔 사용 불가
    SELECT col1, SUM(col2) FROM tb_test GROUP BY col1;
    
    # GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않음
    SELECT col1, col2 FROM to_test GROUP BY col2, col3;
    
    # SELECT 절의 칼럼이 GROUP BY와 일치하지 않기 때문에 사용 불가
    SELECT col1, col3, FROM tb_test GROUP BY col1, col2;
    ```
    
<br>

**임시 테이블을 사용하는 GROUP BY**

GROUP BY의 기준 칼럼이 드라이빙 혹은 드리븐 테이블에 있는것과 관게없이 인덱스를 전혀 사용하지 못할때는 임시 테이블로 처리 됩니다.

```sql
EXPLAIN 
SELECT e.last_name, AVG(s.salary) 
FROM employees e, salaries s 
WHERE s.emp_no=e.emp_no 
GROUP BY e.last_name;
+----+-------------+-------+------------+------+---------------+---------+---------+--------------------+--------+----------+-----------------+
| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref                | rows   | filtered | Extra           |
+----+-------------+-------+------------+------+---------------+---------+---------+--------------------+--------+----------+-----------------+
|  1 | SIMPLE      | e     | NULL       | ALL  | PRIMARY       | NULL    | NULL    | NULL               | 300584 |   100.00 | Using temporary |
|  1 | SIMPLE      | s     | NULL       | ref  | PRIMARY       | PRIMARY | 4       | employees.e.emp_no |      9 |   100.00 | NULL            |
+----+-------------+-------+------------+------+---------------+---------+---------+--------------------+--------+----------+-----------------+
```

GROUP BY 조건은 인덱스를 전혀 사용할 수 없는 조건이기에 `Using temporary`가 표시됩니다.

위의 쿼리는 결국 다음과 같은 임시 테이블을 생성하고, 중복 제거 및 집합 함수 연산을 수행합니다. 그리고 조인 결과를 한건씩 가져와 임시 테이블에서 중복 체크 및 INSERT or UPDATE를 실행합니다.

```sql
CREATE TEMPORARY TABLE ... (
		last_name VARCHAR(16),
		salary INT,
		UNIQUE INDEX ux_lastname (last_name)
);
```

- 참고
    - 8.0이전까지는 GROUP BY가 사용된 쿼리는 그루핑되는 칼럼 기준으로 묵시적인 정렬까지 했지만, 8.0부터는 묵시적인 정렬은 하지 않습니다.

<br><br>

### 9.2.5 DISTINCT 처리

DISTINCT는 MIN(), MAX(), COUNT()와 같은 집합 함수와 함께 사용되는 경우와 집합 함수가 없는 경우에 DISTINCT 키워드가 영향을 미치는 범위가 달라집니다.

`집합 함수 + DISTINCT`가 사용되는 쿼리의 실행 계획에서 DISTINCT 처리가 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요합니다. 다만 이때 실행 계획의 Extra 칼럼은 `Using temporary 메시지가 출력되지 않습니다`.

<br>

**SELECT DISTINCT …**

단순히 SELECT DISTINCT 형태의 쿼리 문장은 GROUP BY와 동일한 방식으로 처리 됩니다.

```sql
# 두개는 내부적으로 같은 작업을 수행함
SELECT DISTINCT emp_no FROM salaries;

SELECT emp_no FROM salaries GROUP BY emp_no;
```

또한 **SELECT 절에서 사용되는 DISTINCT 키워드는 조회되는 모든 칼럼에 영향을 미칩니다. 즉, SELECT 칼럼 중 일부 칼럼만 유니크하게 조회하는것은 불가능합니다. (집합 함수와 사용되는 경우는 다름)**

<br>

**집합 함수와 함께 사용된 DISTINCT**

`집합 함수 + DISTINCT`는 `SELECT DISTINCT`와는 다른 형태로 해석 됩니다.

**집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들을 가져옵니다.**

```sql
EXPLAIN 
SELECT COUNT(DISTINCT s.salary) 
FROM employees e, salaries s 
WHERE e.emp_no=s.emp_no 
	AND e.emp_no BETWEEN 100001 AND 100100;
+----+-------------+-------+------------+-------+---------------+---------+---------+--------------------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref                | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+---------+---------+--------------------+------+----------+--------------------------+
|  1 | SIMPLE      | e     | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL               |  100 |   100.00 | Using where; Using index |
|  1 | SIMPLE      | s     | NULL       | ref   | PRIMARY       | PRIMARY | 4       | employees.e.emp_no |    9 |   100.00 | NULL                     |
+----+-------------+-------+------------+-------+---------------+---------+---------+--------------------+------+----------+--------------------------+
```

위 실행 계획에서 DISTINCT s.salary를 처리하기 위해 임시테이블을 사용하지만 임시 테이블 메시지는 별도로 표시되지 않습니다.

**salary 칼럼은 인덱스가 없으므로 칼럼의 값만 저장하기 위한 임시 테이블을 만들어 사용**하는데 이때 유니크 인덱스도 생성되므로 레코드 건수가 많아지면 상당히 느려지는 형태의 쿼리 입니다.

만약 인덱스된 칼럼에 대해 DISTINCT 처리를 수행할 때는 인덱스 풀 스캔 혹은 레인지 스캔하며 임시 테이블 없이 최적화된 처리를 수행합니다.

```sql
EXPLAIN SELECT COUNT(DISTINCT emp_no) FROM employees;
+----+-------------+-----------+------------+-------+------------------------------------------------------+-------------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type  | possible_keys                                        | key         | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+-------+------------------------------------------------------+-------------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | index | PRIMARY,ix_hiredate,ix_gender_birthdate,ix_firstname | ix_hiredate | 3       | NULL | 300584 |   100.00 | Using index |
+----+-------------+-----------+------------+-------+------------------------------------------------------+-------------+---------+------+--------+----------+-------------+

EXPLAIN SELECT COUNT(DISTINCT emp_no) FROM dept_emp GROUP BY dept_no;
+----+-------------+----------+------------+-------+---------------------------------------+---------+---------+------+--------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys                         | key     | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------------------------------+---------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | dept_emp | NULL       | index | PRIMARY,ix_fromdate,ix_empno_fromdate | PRIMARY | 20      | NULL | 331143 |   100.00 | Using index |
+----+-------------+----------+------------+-------+---------------------------------------+---------+---------+------+--------+----------+-------------+
```

<br><br>

### 9.2.6 내부 임시 테이블 활용

- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬, 그루핑 할때 `내부적`으로 임시 테이블(Internal tmporary table)을 사용합니다.
- 여기서 `내부적`이란 의미는 CREATE TEMPORARY TABLE 명령으로 만든 임시 테이블과는 다르기 때문에 내부적이란 단어가 포함됩니다.
- 일반적인 MySQL 엔진이 사용하는 임시테이블은 처음에는 메모리에 생성됐다가 크기가 커지면 디스크로 옮겨집니다.(특정 예외 케이스에는 즉시 디스크에 생성하기도 함)
- 또한 내부적인 가공을 위해 생성하는 임시테이블은 다른 세션, 쿼리에서 볼 수 없고 사용자가 생성한 임시 테이블과 달리 **내부적인 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제됩니다.**

<br>

**메모리 임시 테이블과 디스크 임시 테이블**

8.0버전부터는 메모리 임시 테이블은 TempTable이라는 스토리지 엔진을, 디스크에 저장되는 임시 테이블은 InnoDB 스토리지 엔진을 사용하도록 개선됐습니다.

**TempTable은 가변 길이 타입을 지원**하고, **InnoDB 스토리지 엔진은 트랜잭션이 지원 가능**하므로 기존의 MEMORY, MyISAM 스토리지 엔진의 문제점을 개선합니다.

- MEMORY or TempTable 사용
    - `internal_tmp_mem_storage_engine` 시스템 변수를 통해 MEMORY, TempTable 중에서 선택할 수 있지만 기본값은 TempTable임
    - TempTable이 최대 사용 가능한 메모리 공간은 temptable_max_ram 시스템 변수로 조절합니다.
    (기본 1GB)

- TempTable → MMAP or InnoDB 테이블로의 변경
    - MMAP 파일, InnoDB 테이블 전환 여부는 `temptable_use_mmap` 시스템 변수로 설정합니다.
    (기본값은 ON)
        - MMAP 파일 전환이 InnoDB 테이블 전환보다 더 적은 오버헤드가 발생함

- 임시 테이블의 삭제 보장
    - 임시테이블 생성시 파일 오픈 후 즉시 파일 삭제를 실행함 그리고 데이터를 저장하기 위해 해당 임시 테이블을 사용합니다.
    - 이렇게 하며 MySQL 서버가 종료되거나 쿼리가 종료되면 임시 테이블은 즉시 사라지게 보장합니다.
    - 따라서 `lsof -p` 와 같은 명령으로 임시 테이블을 확인하면 파일의 상태는 모두 deleted로 표시되는데 이는 임시 테이블의 사용 완료 여부를 의미하진 않게 됩니다.

- 임시 테이블이 즉시 디스크 테이블로 생성되는 경우
    - `internal_tmp_disk_storage_engine` 시스템 변수에 설정된 스토리지 엔진이 사용됨
    (기본값은 InnoDB)

<br>

**임시 테이블이 필요한 쿼리**

다음과 같은 패턴의 쿼리는 MySQL 엔진에서 별도의 데이터 가공 작업을 필요로 하므로 임시 테이블을 생성하는 케이스가 됩니다.

- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리
(실행 계획의 select_type 칼럼이 UNION RESULT인 경우, UNION ALL은 임시테이블 사용 X)
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리
(유니크 인덱스가 없는 내부 임시 테이블을 생성함, 유니크 인덱스가 있는 임시 테이블은 그렇지 않은 쿼리보다 처리 성능이 상당히 느림)

Extra 칼럼에 Using temporary 메시지 유무를 통해 임시 테이블 사용 여부를 알 수 있지만, 위 예시 마지막 3개  패턴은 임시 테이블을 사용하지만 Using temporary 메시지가 표시되진 않습니다.

<br>

**임시 테이블이 디스크에 생성되는 경우**

- UNION이나 UNION ALL에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 `tmp_table_size`(MEMORY 스토리지 엔진) 혹은 `max_heap_table_size` 시스템 변수보다 크거나 `temptable_max_ram`(TempTable 스토리지 엔진) 시스템 변수 값보다 큰 경우

→ 추가로 8.0.13부터는 BLOB, TEXT 칼럼을 가진 임시 테이블에 대해서도 메모리에 임시 테이블을 생성할 수 있게 개선됐습니다. 다만 TempTable 스토리지 엔진만 해당됩니다.

<br>

**임시 테이블 관련 상태 변수**

실행 계획에서 Using temporary 여부로 임시 테이블 사용 여부를 확인하는데, 처리 주체가 메모리인지 디스크인지는 알 수 없고, 몇 개의 임시 테이블을 사용됐는지도 알 수 없습니다.

임시 테이블의 생성 위치 확인은 `SHOW SESSION STATUS LIKE ‘Created_tmp%’;`를 확인하면 됩니다.

```sql
SELECT first_name, last_name 
FROM employees 
GROUP BY first_name, last_name;

SHOW SESSION STATUS LIKE 'Created_tmp%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Created_tmp_disk_tables | 1     |
| Created_tmp_files       | 0     |
| Created_tmp_tables      | 1     |
+-------------------------+-------+
```

- `Created_tmp_disk_tables`: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값 (메모리, 디스크 구분 X)
- `Created_tmp_tables`: 디스크에 내부 임시 테이블이 만들어진 개수만 누적하여 가지고 있는 상태값
- `Created_tmp_files`: MySQL 서버가 생성한 임시 파일의 개수
