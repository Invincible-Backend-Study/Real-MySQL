# 📌 4장 아키텍처

- $MySQL 서버 = MySQL 엔진 + 스토리지 엔진$
- MySQL 엔진: 사람의 머리 역할
- 스토리지 엔진: 손발 역할 → 핸들러 API를 만족하면 누구든지 스토리지 엔진을 구현하여 MySQL 서버에 추가하여 사용할 수 있다.

<br><br><br>

## ✅ 4.1 MySQL 엔진 아키텍처

- MySQL 서버는 다른 DBMS에 비해 독특한 구조를 가짐
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/d750d8c7-c771-4f4a-973c-0f1851ad4999)

<br>    

**MySQL 엔진**

커넥션 핸들러(클라이언트 접속 및 쿼리 요청 처리), SQL 파서 및 전처리기, 옵티마이저(쿼리의 최적화된 실행)가 중심을 이룸 또한 ANSI SQL을 지원함(ANSI를 따르는 타 DBMS와 호환성)

1개만 존재함

<br>

**스토리지 엔진**

실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 역할을 전담함

여러개의 스토리지 엔진을 동시에 사용할 수 있음

```sql
# 테이블이 사용할 스토리지 엔진으로 INNODB 지정
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

각 스토리지 엔진은 성능 향상을 위해 키 캐시, InnoDB 버퍼 풀(InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있음

<br>

**핸들러 API**

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽을때 각 스토리지 엔진에게 요청하는 이런 요청을 `핸들러 요청`이라함, 또한 여기서 사용되는 API를 `핸들러 API`라고 함

핸들러 API로 데이터(레코드)작업을 확인하려면 `SHOW GLOBAL STATUS LIKE ‘Handler%’;` 명령으로 확인 가능

<br><br>

### 4.1.2 MySQL 스레딩 구조

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/55855609-925f-42bc-8453-2d5bd8cf202d)


MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동합니다. 스레드는 크게 Foreground와 Background 스레드로 구분할 수 있습니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/70019bb0-1c99-474d-b93f-620870fce8f6)


- `thread/sql/one_connection 스레드가 실제 사용자의 요청을 처리하는 포그라운드 스레드`
- 동일 이름의 스레드가 2개 이상인건 MySQL 서버의 설정 내용에 의해 스레드가 동일 작업을 병렬로 처리함
- `전통적 스레드 모델`에선 커넥션별로 포그라운드 스레드가 하나씩 생성되고 할당됨(1:1)
    - `스레드 풀`은 하나의 스레드가 여러개의 커넥션 요청 전담함 (1:N)

<br>

**포그라운드 스레드(클라이언트 스레드) == 사용자 스레드 dd**

- MySQL서버에 접속된 클라이언트 수만큼 존재
- 각 클라이언트 사용자가 요청하는 쿼리를 처리하고 커넥션을 종료하면 스레드는 다시 스레드 캐시로 돌아감 이때 일정 개수 이상의 대기 스레드가 있다면 스레드 캐시에 넣지 않고 스레드를 종료시킴
    
    참고자료: [MySQL :: MySQL Connection Handling and Scaling](https://dev.mysql.com/blog-archive/mysql-connection-handling-and-scaling/)
    
- 일정 개수의 스레드만 존재하는데 최대 스레드 개수는 thread_cache_size 시스템 변수로 설정함

InnoDB 테이블은 데이터 버퍼까지만 `포그라운드 스레드`가 처리하고, 버퍼에서 디스크까지 기록하는 작업을 `백그라운드 스레드`가 처리한다.

(MyISAM은 포그라운드 스레드가 전부 처리함)

<br>

**백그라운드 스레드**

InnoDB는 여러 작업이 백그라운드로 실행

- Insert Buffer를 병합하는 스레드
- `로그를 디스크로 기록하는 스레드`
- `InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드`
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금, 데드락 모니터링 스레드

<br>

**가장 중요한건 로그 스레드, 쓰기 스레드**

읽는 작업은 포그라운드 스레드에서 처리되므로 적어도 되지만, 쓰기 스레드는 많은 작업이 백그라운드에서 실행되므로 충분히 설정해야 함

상용 디비(및 InnoDB)에서 읽기 작업은 즉시 읽어서 반환해야 하므로 절대 지연되면 안됨 (버퍼링 X) 다만 쓰기 작업은 지연(버퍼링)되어 일괄 처리 가능

이런 버퍼링 덕분에 C,U,D에서 데이터가 디스크까지 저장되는걸 기다리지 않아도 됨

<br><br>

### 4.1.3 메모리 할당 및 사용 구조

- MySQL에서 사용되는 메모리 공간은 글로벌 메모리, 로컬 메모리 영역으로 구분됨
- 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작될때 운영체제로부터 할당됨

메모리를 구분하는 방식은 MySQL 서버 내의 스레드가 공유해서 사용하는 공간인지 아닌지 여부에따라 결정됨

<br>

**글로벌 메모리 영역**

- 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당
- 생성된 글로벌 영역이 N개 이상이더라도 모든 스레드에 의해 공유 가능

대표적으로 `테이블 캐시`, `InnoDB 버퍼 풀`, `InnoDB 어댑티브 해시 인덱스`, `InnoDB 리두 로그 버퍼`가 존재

<br>

**로컬 메모리 영역(== 세션 메모리 영역, 클라이언트 메모리 영역)**

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/ed9cd389-4e52-4534-a208-8d5a028c602b)


로컬 메모리 영역은 `정렬 버퍼`, `조인 버퍼`, `바이너리 로그 캐시`, `네트워크 버퍼`가 있다.

- 클라이언트 스레드가 쿼리를 처리하는데 사용되는 메모리 영역
    - 클라이언트가 MySQL 서버에 접속하면 MySQL 서버에서 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당함(위 그림) → 이때 클라이언트가 사용하는 메모리 공간임
- 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않음
- **커넥션이 열려있는 동안 계속 할당된 상태로 남아있는 공간(커넥션 버퍼, 결과 버퍼)와 쿼리 실행 순간에만 할당하고 해제하는 공간(소트 버퍼, 조인버퍼)가 있다.**

<br><br>

### 4.1.4 플러그인 스토리지 엔진 모델

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/462d53e1-b641-456e-92da-22477d5d7074)


- MySQL의 독특한 구조인 플러그인 모델입니다.
- 스토리지 엔진, 검색어 파서, 사용자 인증 등 다양한 것들이 플러그인으로 구현되어 제공됨
- 사용자가 직접 스토리지 엔진을 개발 할 수 있음
- MySQL에서 쿼리가 실행되는 과정에서 스토리지 엔진의 처리 영역은 다음과 같음
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/9532de97-e5d2-4e60-97f2-e28c1a50b2c5)

    
    - 데이터 읽기/쓰기 작업은 대부분 1건의 레코드 단위로 처리됩니다.
    - MySQL 엔진은 각 스토리지 엔진에게 데이터를 읽거나 저장할때는 반드시 핸들러를 통해야 합니다.
    - 다른 스토리지 엔진을 사용해도 앞단의 처리내용은 대부분 동일(MySQL 엔진의 영역) 마지막 데이터 읽기/쓰기 에서 차이가 있습니다.
    - 또한 하나의 쿼리 작업이 여러 하위 작업으로 나뉠때 어떤 영역(MySQL 엔진, 스토리지 엔진에서 처리되는지 구분할 줄 알아야 합니다.
    - SHOW ENGINES, SHOW PLUGINS와 같은 명령어로 스토리 엔진 및 플러그인 확인 가능 (책 88p참조)

<br><br>

### 4.1.5 컴포넌트

컴포넌트는 플러그인의 단점을 보완하고 기존의 플러그인 아키텍처를 대체하기 위해 8.0부터 지원합니다.

플러그인의 대표적인 단점은 다음과 같습니다.

- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고 `플러그인끼리 통신할 수 없음`
- MySQL 서버의 변수나 함수를 직접 호출하므로 안전하지 않음 (No 캡슐화)
- 플러그인은 상호 의존 관계 설정 불가하므로 초기화 어려움

<br><br>

### 4.1.6 쿼리 실행 구조

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/5cac0e29-0ede-4ac3-b999-68f6d37d3122)

<br>

**쿼리 파서 dd**

- 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)로 분리해 트리 형태의 구조로 만들어 내는 작업을 함 → 기본 문법 오류를 발견 및 사용자에게 알려줌

참고자료: [MySQL :: MySQL 8.0: Refactoring and Improving the Parser](https://dev.mysql.com/blog-archive/mysql-8-0-labs-refactoring-and-improving-the-parser/)

<br>

**전처리기**

- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점을 확인함
- 각 토큰을 테이블 이름, 칼럼 이름, 내장 함수에 매핑하여 존재 여부 및 접근 권한 등을 여기서 확인함

<br>

**옵티마이저**

- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 경정하는 역할, DBMS의 두뇌를 담당한다.

<br>

**실행 엔진 및 핸들러**

- 실행 엔진(중간 관리자)과 핸들러(실무자)로 비교됨
- 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행함
- 핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당함

<br><br>

### 4.1.8 쿼리 캐시

- 쿼리 캐시는 동일 SQL 쿼리가 실행되면 즉시 결과를 반환할 수 있도록 쿼리를 캐싱하지만, 데이터가 변경됐을때 심각한 동시 처리 성능 저하를 유발하고 많은 버그의 원인이 됐으므로 8.0부터 완전히 제거됐습니다.

<br><br>

### 4.1.9 스레드 풀(Percona Server 제공)

- MySQL 서버 엔터프라이즈 에디션은 스레드 풀 기능을 제공합니다. (커뮤니티는 제공 X)
(다만 커뮤니티 에서도 플러그인 형태로 Percona Server를 사용하면 스레드 풀을 사용할 수 있습니다.)
- 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여 동시 처리되는 요청이 많아도 제한된 개수의 스레드 처리에만 집중할 수 있게해 서버 자원 소모를 줄이는것이 목적
- **운영체제 입장에선 불필요한 컨텍스트 스위칭 비용을 줄여 오버헤드를 낮춤**
- `thread_pool_size`: 동시에 실행될 수 있는 스레드 개수
- `thread_pool_max_size`: 스레드풀에 들어갈 수 있는 최대 스레드 개수
- `thread_pool_stall_limit`: 모든 스레드가 일을 하고 있을때 작업 스레드를 추가할지, 스레드가 처리를 완료하는걸 기다릴지 여부를 판단하는 기준값, 이 시간을 초과해도 스레드가 처리 중인 작업을 끝내지 못하면 새로운 스레드를 생성해 스레드 그룹에 추가함

<br>

**스레드 풀이 운영체제에서 발생하는 불필요한 컨텍스트 스위치 오버헤드를 낮춰주는 이유 dd**

참고자료: [MySQL :: The New MySQL Thread Pool](https://dev.mysql.com/blog-archive/the-new-mysql-thread-pool/)

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/68b6e695-9db9-479c-b173-a7c20ff242dd)


- 기존: MySQL has a default connection handling model called **"one-thread-per-connection." In this model, when a user connects to the server, a dedicated OS thread is created for the connection.**
    
    **→ 연결을 위한 스레드를 OS에게 할당 받음**
    
- 스레드 풀 사용 이점: The MySQL Thread Pool introduces a separation between user connections and threads. Unlike the previous model, each **user connection no longer has its own dedicated OS thread to execute statements.** Instead, the Thread Pool is composed of Thread Groups, with a default of 16 Thread Groups. User connection is assigned to Thread Group in a round-robin fashion. Each Thread Group manages a subset of user connections. Within each Thread Group, there are one or more threads responsible for executing queries received from the user connection assigned to that Thread Group.
    
    **→ 사용자 연결에 명령문을 사용하는 전용 OS 스레드가 없음, 스레드 풀은 스레드 그룹으로 관리되며 사용자 연결은 라운드 로빈 방식으로 스레드 그룹에 할당됩니다.(receiver thread에 의해)**
    
<br><br>

### 4.1.10 트랜잭션 지원 메타데이터

- 테이블의 구조 정보, 스토어드 프로그램 등의 정보를 `데이터 딕셔너리` 혹은 `메타데이터`라고 함
- 5.7까지는 테이블의 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램을 TRN, TRG, PAR 파일 기반으로 관리함 → `트랜잭션을 지원하지 않으므로 테이블 생성, 변경 중 비정상적인 종료시 일관되지 않은 데이터 상태가 되는경우가 있음` → DB가 깨졌다.
- 8.0부터 테이블 구조 정보, 스토어드 프로그램 코드 등을 InnoDB 테이블에 저장하도록 개선됨(시스템 테이블이라 함 대표적으로 사용자 인증 및 권한 관련)
- 이런 시스템 테이블은 모두 InnoDB 스토리지 엔진을 사용하도록 개선함 → 덕분에 비정상적인 종료가 있어도 스키마 변경이 완전 성공 혹은 실패로 귀결됩니다.
- mysql DB에 저장되고 통째로 mysql.ibd이름의 테이블 스페이스에 저장됨

다만 스토리지 엔진 자체에 대한 메타 정보는 아직 SDI(Serialized Dictionary Information)라는 파일을 사용합니다.

<br><br><br>

## ✅ 4.2 InnoDB 스토리지 엔진 아키텍처

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/4d01fa8c-8392-4ce4-bdd8-5e5d76368f3b)


InnoDB 스토리지 엔진은 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공합니다. 덕분에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어납니다.

<br>

**레코드 기반의 잠금**

인덱스 레코드에 대한 잠금으로 아래 예시에서 다른 트랜잭션이 t.c1의 값이 10인 행을 삽입, 업데이트 또는 삭제하지 못하도록 합니다.

```sql
# 가장 먼저 락을 획득한 세션에서 셀렉트한 row들이 update 쿼리 후 commit이 되기 이전까지
# 다른 session이 접근하지 못하도록함
SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE; 
```

레코드 잠금은 테이블이 인덱스 없이 정의된 경우에도 항상 인덱스 레코드를 잠급니다. 이러한 경우 InnoDB는 숨겨진 클러스터된 인덱스를 생성하고 이 인덱스를 레코드 잠금에 사용합니다.

<br><br>

### 4.2.1 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링 되어 저장됩니다.
(PK값 순서대로 디스크에 저장됨)
- 모든 세컨더리 인덱스는 레코드의 주소 대신 PK의 값을 논리적인 주소로 사용합니다.
- PK는 정렬되어 저장되므로 레인지 스캔을 빨리 처리할 수 있음
이러한 특성으로 다른 보조 인덱스에 비해 쿼리 실행 계획에서 PK가 선택될 확률이 높습니다.

<br>

**Clustered Index**

- InnoDB 스토리지 엔진에서 Table의 기본키를 정의하면 클러스터된 인덱스로 등록 됩니다.
- 테이블당 하나의 클러스터된 인덱스를 가지며 insert시 데이터가 PK값 기준으로 정렬됩니다.

<br>

**Secondary index**

- PK 이외에 필요한 정렬 기준이 있을때 사용되며 테이블당 여러개를 가질 수 있습니다.
- 인덱스는 정렬되어 있지만 data record가 정렬되어 있지 않습니다.
    - 따라서 클러스터된 인덱스보다 C, U, D 속도가 비교적 빠릅니다. → 데이터 페이지에 정렬 순서 상관 없이 빈 곳에 데이터를 삽입하면 되므로

<br><br>

### 4.2.2 외래 키 지원

- InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 다른 스토리지 엔진에선 사용할 수 없습니다.
- InnoDB 외래키는 부모 테이블, 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요합니다.
- 변경 시엔느 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파됩니다. (데드락 조심 및 외래키 존재에 주의 해야 함)

<br><br>

### 4.2.3 MVCC(Multi Version Concurrency Control)

- **Multi Version** → 하나의 레코드에 대해 여러 개의 버전이 동시에 관리됨 → 트랜잭션 격리 수준에 따라 버전이 달라짐
- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며 **MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있습니다.**
- InnoDB는 언두로그를 이용해 MVCC를 구현 합니다.

<br>

**왜 Multi Version 일까?**

```sql
# 데이터 삽입
INSERT INTO member (m_id, m_name, m_area) values (12, '이호석', '횡성');
COMMIT;

# UPDATE 이후 커밋 전
UPDATE member SET m_area='판교' WHERE m_id=12;

# UPDATE 쿼리 이후 다른 사용자가 조회하게 되면 어떤 값을 보여줄까?
SELECT * FROM member WHERE m_id=12;
```

InnoDB 버퍼 풀은 COMMIT 실행 여부와 상관 없이 새로운 값인 `판교`로 업데이트 됩니다.
이때 다른 사용자가 조회하게 되면 트랜잭션 격리 수준에 따라 보여주는 값이 달라집니다.

- **READ_UNCOMMITTED**: InnoDB 버퍼 풀이 가지고 있는 데이터 보여줌
- **READ_COMMITTED**, **REPEATABLE_READ**, **SERIALIZABLE**: 커밋되지 않은 이전의 값을 보여줘야 하므로 언두 로그 영역의 값을 반환함
- **COMMIT**이 되면 InnoDB는 현재 상태를 영구적인 데이터로 만듭니다.
- 하지만 **ROLLBACK**을 하게 되면 언두 로그의 백업 데이터를 InnoDB 버퍼 풀로 다시 복구하고 언두 로그의 데이터를 조건이 맞다며 삭제합니다. (필요로 하는 트랜잭션이 더는 없을때)

이렇게 필요에 따라 다른 버전의 데이터를 보여주게 되므로 `Multi Version`이라고 말하게 되고, 아직 커밋을 수행하지 않았다고 하더라도 다른 사용자의 SELECT 작업을 방해하지 않으므로 `잠금 없는 일관된 읽기`라고도 표현합니다. (InnoDB는 변경 되기 전의 데이터를 읽기 위해 언두 로그를 사용함)

언두 로그는 트랜잭션이 롤백 혹은 커밋이 되지 않는다면 삭제하지 못하므로 가능한 빨리 트랜잭션을 완료해주는것이 성능 저하를 예방할 수 있습니다.

<br><br>

### 4.2.5 자동 데드락 감지

- InnoDB 스토리지 엔진은 내부적으로 잠금 교착 상태를 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리하고 **데드락 감지 스레드**를 사용합니다.
- 데드락 감지 스레드는 교착 상태에 빠진 트랜잭션들을 찾아서 강제 종료합니다.
    - 강제 종료 기준은 더 적은 언두 로그의 양을 가진 트랜잭션을 먼저 롤백합니다. → 서버의 부하가 덜 유발되므로
    - 다만 LOCK TABLES 명령으로 잠긴 테이블은 MySQL 엔진에서 관리되는 테이블 잠금으로 데드락 감지가 불확실할 수 있습니다. 이때는 innodb_table_locks 시스템 변수를 활성화 시켜 레코드 및 테이블 레벨의 잠금까지 감지할 수 있게 할 수 있습니다.
- 데드락 감지 스레드는 잠금 목록을 검사할때 상태 변경을 막기 위해 새로운 잠금을 걸고 데드락 스레드를 찾는데 데드락 감지 스레드가 느려지면 서비스에 악영향을 미칠 수 있습니다.
    - 이런 상황을 방지하기 위해 여러 시스템 변수를 설정할 수 있습니다.
        - innodb_deadlock_detect: ON, OFF 설정으로 데드락 감지 스레드를 끄고 킴
        - innodb_lock_wait_timeout: 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환함

<br>

**LOCK TABLES 명령어의 잠금범위는 단일 MySQL 서버다.**

참고자료: [MySQL :: MySQL 8.0 Reference Manual :: 13.3.6 LOCK TABLES and UNLOCK TABLES Statements](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html#lock-tables-restrictions)

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/b126aec8-a92c-4412-b535-600106c9f828)


<br><br>

### 4.2.6 자동화된 장애 복구

- InnoDB엔 손실 및 장애로부터 데이터를 보호하기 위한 여러가지 매커니즘이 탑재되어 있습니다.
- 주로 MySQL 서버가 시작될때 일련의 복구작업이 자동으로 진행됩니다.
- 복구작업을 위해 `innodb_force_recovery` 시스템 변수를 `1 ~ 6`까지 설정해가며 MySQL 서버를 시작할 수 있습니다.
- innodb_force_recovery를 모두 적용해도 MySQL 서버가 시작되지 않으면 바이너리 로그를 사용해 최대한 장애 시점까지 데이터를 복구하고 DB를 재 구축해야 합니다.

→ 1~6 설정에 대한 자세한 내용은 책 106page를 참고

<br><br>

### 4.2.7 InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간입니다.
- 또한 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 합니다.

<br>

**버퍼 풀의 크기 설정**

- 레코드 버퍼는 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용되는 공간을 말합니다.
- 커넥션이 많아지고 사용하는 테이블도 많아진다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 많이 필요해질 수 있습니다.
- 5.7 버전부터 InnoDB 버퍼 풀의 크기를 `innodb_buffer_pool_size` 시스템 변수를 통해 동적으로 조절할 수 있게 개선 됐습니다.
- 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 상황을 봐 가며 증가시키는 방법이 최적입니다.
    - 버퍼 풀의 증감은 128MB 단위로 처리 됩니다.
    - `innodb_buffer_pool_instance` 시스템 변수를 통해 버퍼 풀을 여러개로 쪼개어 관리할 수 있습니다. (버퍼 풀 전체에 대한 잠금 경합을 개선)
    - 버퍼 풀을 위한 메모리 크기가 1GB 미만이라면 버퍼 풀 인스턴스는 1개만 생성되고 그 외에는 8개로 초기화 됩니다.

<br>

**버퍼 풀의 구조 dd**

- InnoDB 스토리지 엔진은 버퍼 풀이라는 메모리 공간을 페이지 크기의 조각으로 쪼갭니다.(`innodb_page_size` 변수에 설정된 크기이며 데이터 페이지라 함)
- InnoDB 스토리지 엔진이 데이터를 필요로 할때 해당 데이터 페이지를 읽어서 각 조각에 저장합니다.
- 버퍼 풀의 페이지 크기 조각을 관리하기 위한 자료구조로 `LRU`, `Flush`, `Free` 리스트라는 3개의 자료구조를 관리합니다.

- `프리 리스트`: 실제 사용자 데이터로 채워지지 않은 비어있는 페이지들의 목록
- `LRU 리스트`: 엄밀하게는 $LRU(Old) + MRU(Young)$리스트가 결합된 형태입니다.
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/8a999026-5f88-4453-afc2-624a331556c1)

    출처: https://cl8d.tistory.com/102
    
    - 초기에는 5/8 지점인 Old 서브리스트 헤더에 적재하게 됩니다.
    - 적재된 페이지가 읽히면 New 서브리스트의 헤더 부분으로 이동
    (Read Ahead와 같은 대량읽기는 제외)
    - 요청 데이터가 hit 될때마다 New 서브 리스트의 헤더 부분으로 이동하게 되고 반대로 hit되지 않을때마다 점점 Old 서브리스트의 tail로 가다가 제거됩니다.
    - 자주 접근된 데이터가 있다면 페이지의 인덱스 키를 Adaptive Hash Index에 추가함
- `플러시 리스트`: 디스크로 동기화 되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리함
    - 한 번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점에 디스크에 기록해야 합니다.
    - 데이터 변경시 리두 로그에 기록하게 되므로 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결됩니다.
    - InnoDB 스토리지 엔진은 체크포인트를 통해 리두 로그와 데이터 페이지의 상태를 동기화하게 됩니다.
    - 체크 포인트는 MySQL 서버가 시작될때 InnoDB 스토리지 엔진이 리두 로그의 어느 부분부터 복구를 실행해야 할지 판단하는 기준점을 만드는 역할을 합니다.

<br>

**버퍼 풀의 구조: 내 컴퓨터의 페이지 개수 계산해보기**

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/f8453f25-9d35-4b70-a3f4-11a7ab5da510)


![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/3aa39ab4-395e-4c14-874b-42f295224671)


현재 버퍼 풀의 사이즈: `2^27 (128MB)`

버퍼 풀의 페이지 사이즈: `2^14(16KB)`

버퍼 풀의 페이지의 개수: $2^{27} / 2^{14} = 2^{13}$개 (8192개의 페이지)

<br>

**버퍼 풀과 리두 로그 dd**

- InnoDB 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있습니다.
- InnoDB 버퍼 풀은 DB 서버의 성능 향성을 위해 `데이터 캐시`와 `쓰기 버퍼링`이라는 용도가 있습니다.
    - 단순히 버퍼 풀의 메모리 공간만 늘리면 데이터 캐시 기능만 향상시키게 됩니다.
    - 쓰기 버퍼링의 기능을 향상시키려면 InnoDB 버퍼 풀과 리두 로그와의 관계를 먼저 이해해야 합니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/64736071-02b0-4f86-b147-affbbf25af8b)

출처: https://new-age-jh.tistory.com/288

- 리두 로그는 순환 고리 처럼 사용됩니다. 즉 이전의 데이터가 덮일 수 있기때문에 재사용 가능 공간과 불가능한 공간을 구분할 수 있어야 합니다.
- 재사용 불가능한 공간을 `활성 리두 로그(Active Redo Log)`라고 하며 화살표를 가진 엔트리를 말합니다.
- 리두 로그는 `LSN(Log Sequence Number)`라는 번호를 갖게 되며 스토리지 엔진의 주기적인 체크포인트를 통해 더티 페이지를 디스크로 동기화 시킵니다.
- 체크포인트가 발생하면 `마지막 체크포인트 지점의 LSN`부터 `가장 마지막에 추가된 활성 리두 로그의 LSN` 범위의 더티 페이지들이 디스크로 동기화 됩니다.
    - 위 범위를 Checkpoint Age(활성 리두 공간의 크기)라고 합니다.

<br>

**버퍼 풀 플러시**

- 8.0 버전부터 더티 페이지를 디스크로 동기화 하는 부분(더티 페이지 플러시)에서 디스크 쓰기 폭증 현상은 거의 발생하지 않습니다.
- InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향없이 디스크에 동기화 하기 위해 2개의 플러시 기능을 백그라운드로 실행합니다.
- 실행하는 플러시 기능: `Flush_list 플러시`, `LRU_list 플러시` → 자세한 내용은 114 ~ 117P 책 참조

<br>

**버퍼 풀 상태 백업 및 복구**

- MySQL 서버를 재시작하면 쿼리 처리 성능이 평소에 1/10으로 줄게 되는데 디스크의 데이터가 버퍼 풀에 적재되어 있지 않기 때문입니다.
- 반대로 디스크 데이터가 버퍼 풀에 적재된 상황을 `워밍업` 이라고 합니다.
    - 서버를 다시 켰을때도 이런 워밍업을 유지하기 위해 InnoDB 버퍼 풀의 상태를 백업할 수 있습니다.
    - 다만 백업되는 내용은 데이터 페이지의 메타데이터 이므로 실제 내용을 버퍼 풀로 복구하는 과정은 상당한 시간이 걸릴 수 있습니다.
- 시스템 변수 및 백업하는 자세한 내용은 117 ~ 118P 참조

<br>

**버퍼 풀의 적재 내용 확인**

- `5.6`버전 부터 `information_schema.INNODB_BUFFER_PAGE` 테이블을 이용해 버퍼 풀 메모리의 테이블 페이지 적재를 확인할 수 있었지만 풀이 큰 경우 조회 자체에 큰 부하가 발생하여 서비스 쿼리가 느려지는 문제가 있었습니다.
- `8.0`부터는 `information_schema.INNODB_CACHED_INDEXES` 테이블이 추가되어 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인할 수 있습니다.
    
    ```sql
    SELECT it.name table_name, ii.name index_name, ici.n_cached_pages n_cached_pages 
    FROM information_schema.innodb_tables it 
      INNER JOIN information_schema.innodb_indexes ii ON ii.table_id = it.table_id 
      INNER JOIN information_schema.innodb_cached_indexes ici ON ici.index_id = ii.index_id;
    ```
    
    ![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/45e90a6a-8221-43fa-8f3a-c1281df9ab0c)

    
<br><br>

### 4.2.8 Double Write Buffer

리두 로그에는 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록합니다. 하지만 더티 페이지를 디스크로 동기화 할때 일부만 기록된다면 복구하기 어려울 수 있습니다. → 복구하기에 정보가 부족하므로

이런 현상은 하드웨어 오작동 혹은 비정상 종료에 의해 발생되며 `Partial-page` or `Torn-page` 라고 합니다.

이런 현상을 막기 위해 Double Write 기법을 사용합니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/a9a0a204-8bd4-45e1-85e1-c5bc748e2bbf)


- 위 그림에서 더티 페이지를 디스크에 기록하기 전에 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록을 합니다.
- 만약 비정상적인 상황으로 인해 C페이지만 누락되고 종료됐다면 재시작시 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교합니다.
- 그 중에서 다른 내용을 담고 있는 페이지(C)를 데이터 파일 페이지로 복사합니다.
- `innodb_doublewrite` 시스템 변수로 제어할 수 있습니다.

→ SDD는 버퍼링을 위해 한 번의 기록이 추가되는 상황이 상당히 부담스럽습니다.(NAND 플래시의 특성 때문에)

→ 무결성이 매우 중요한 서비스에서는 활성화를 고려하는편이 좋습니다.

<br><br>

### 4.2.9 언두 로그

InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업합니다. 이를 언두 로그라고 합니다.

- 트랜잭션 보장
    
    트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 함 이때 `언두 로그에 백업한 이전 버전 데이터를 활용`
    
- 격리 수준 보장
    
    트랙잭션 격리 수준이 READ COMMITTED, REPEATABLE READ ,SERIALIZABLE이고 커밋되지 않은 데이터를 조회하면 언두 로그를 조회함 → 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽을지 말지가 결정됨
    
<br>

**과거 버전에서의 문제와 현재 버전에서 언두 로그 모니터링**

MySQL 5.5 이전 버전에선 한 번 증가한 언두 로그 공간은 다시 줄지 않았고, 트랜잭션이 오랫동안 실행 되어도 언두 로그의 양이 급격히 증가했습니다.

- A → B → C 순서로 트랜잭션 요청이 들어왔고, A를 제외한 B, C가 모두 커밋되어도 먼저들어온 트랜잭션이 실행중이므로  **B, C의 언두 로그가 삭제되지 않게 됩니다.**
- 언두 로그가 쌓인 상태에서 변경된 레코드를 조회할때 언두 로그를 스캔하면(트랜잭션 격리 수준에 의해) 필요한 레코드를 찾는데 쿼리의 성능이 떨어지게 됩니다.

MySQL 8.0 부터는 언두 로그를 순처적으로 사용하며 디스크 공간을 줄이거나 MySQL 서버가 필요한 시점에 자동으로 줄여주기도 합니다.

또한 주기적인 언두 로그 모니터링을 통해 확인해주는것이 좋습니다.

```sql
# 언두 로그 건수 확인

## TRANSACTION 파트 (모든 버전)
SHOW ENGINE INNODB STATUS 

## 8.0버전에서 사용가능
SELECT count FROM information_schema.innodb_metrics
WHERE SUBSYSTEM='transaction' AND NAME='trx_rseg_history_len';
```

위 명령어는 UPDATE, DELETE 문장으로 인한 언두 로그 개수만 표시 됩니다.

INSERT는 롤백 및 데이터 복구만 신경쓰면 되지만 UPDATE, DELETE는 MVCC와 데이터 복구(롤백 포함) 모두 신경써야하므로 별도로 관리됩니다.

<br>

**언두 테이블스페이스 관리**

언두 로그가 저장되는 공간을 언두 테이블스페이스라고 합니다.

8.0버전 부터는 언두 로그를 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 합니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/355eee75-1fa9-4c3e-a3f8-70bda1614703)


`1개의 언두 테이블스페이스`: 128개 이하의 롤백 세그먼트 가짐

`1개의 롤백 세그먼트`: InnoDB 페이지 크기를 16바이트로 나눈 값의 개수만큼의 언두 슬롯을 가짐 

`트랜잭션 하나당 필요한 언두 슬롯`: 2개

따라서 `최대 동시 트랜잭션 수` = `(InnoDB 페이지 크기)` / `16` * `(롤백 세그먼트 개수)` * `(언두 테이블 스페이스의 개수)` / `2(트랜잭션 하나당 필요한 언두 슬롯)`

→ 언두 로그 슬롯이 부족하면 트랜잭션을 시작할 수 없는 심각한 문제가 발생하므로 적절한 설정이 필요합니다.

→ 언두 테이블스페이스의 동적인 추가 및 삭제는 `127p 참고`

- **Undo tablespace truncate**
    - 언두 테이블스페이스 공간을 필요한 만큼 남기고 과도하게 혹은 불필요한 공간을 운영체제로 반납함
    - 자동 모드: `innodb_undo_log_truncate=ON` InnoDB 스토리지 엔진의 퍼지 스레드가 주기적으로 깨어나서 불필요한 언두 로그 삭제 작업 실행함 
    (작업의 빈도는 innodb_purge_rseg_truncate_frequency 변수값을 조정하면 됨)
    - 수동 모드: `innodb_undo_log_truncate=OFF`, 언두 테이블스페이스를 직접 비활성화하면 퍼지 스레드가 불필요한 공간을 잘라냄, 다만 최소 3개 이상의 언두 테이블스페이스가 있어야 수동모드에서 동작함

<br><br>

### 4.2.10 체인지 버퍼

RDBMS에서 INSERT, UPDATE `파일 변경 + 인덱스 업데이트 작업도 필요`

→ 인덱스 업데이트는 랜덤하게 디스크를 읽는 작업이 필요함

→ InnoDB 버퍼 풀에 이전 인덱스가 없을 수 있기 때문

이런 랜덤한 작용때문에 일단 업데이트를 즉시하지 않고 임시 공간에 저장하고 사용자에게 바로 결과를 반환함

→ 이를 **체인지 버퍼**라고 한다. 덕분에 성능 향상됨

다만 중복 체크를 위한 PK같은 유니크 인덱스 들은 체인지 버퍼를 사용할 수 없음

→ 반드시 중복 체크를 해야 하니까 인덱스를 읽어야 함

체인지 버퍼에 저장된 인덱스 레코드 조각들은 백그라운드 스레드에 의해 병합되는데 이를 `change buffer merge thread`라고 합니다.  8.0부터는 `insert` `delete` `update`를 통해 키 추가 및 삭제 작업에 대한 버퍼링을 모두 지원합니다 

또한 5.5 이후부턴 innodb_change_buffering 시스템 변수를 통해 작업의 종류별로 체인지 버퍼 활성화 유무를 지정할 수 있습니다.

- all: 모든 인덱스(C, U, D) 관련 작업을 버퍼링
- none: 버퍼링 X
- inserts: INSERT만
- deletes: DELETE만
- changes: INSERT + DELETE만
- puges: 인덱스 아이템을 영구적으로 삭제하는 작업만 버퍼링

체인지 버퍼는 InnoDB 버퍼 풀로 설정된 메모리 공간의 25%까지 사용할 수 있게 설정되어 있고, 필요하다면 50%까지 올릴 수 있습니다.

버퍼 풀의 메모라 사용량 및 변경 사항을 얼마나 버퍼링 하고 있는지 확인할 수 있음

```sql
# 체인지 버퍼가 사용중인 메모리 공간의 크기
SELECT EVENT_NAME, CURRENT_NUMBER_OF_BYTES_USED
FROM performance_schema.memory_summary_global_by_event_name
WHERE EVENT_NAME='memory/innodb/ibuf01buf';

# 체인지 버퍼 관련 오퍼레이션 횟수
SHOW ENGINE INNODB STATUS

-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 34679, node heap has 1 buffer(s)
Hash table size 34679, node heap has 0 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
Hash table size 34679, node heap has 3 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
Hash table size 34679, node heap has 0 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
0.00 hash searches/s, 0.00 non-hash searches/s
```

<br><br>

### 4.2.11 리두 로그 및 로그 버퍼

- 일반적인 DBMS의 데이터 파일은 쓰기보다 읽기 성능을 고려한 자료 구조를 가지고 있기에 데이터 파일 쓰기는 디스크의 랜덤 액세스가 필요합니다.
- 이런 성능 저하를 막기 위해 쓰기 비용이 낮은 자료 구조를 가진 리두 로그를 두고 있습니다.
- 더불어 리두 로그 자체를 버퍼링할 수 있는 InnoDB 버퍼 풀과 로그 버퍼와 같은 자료구조 있습니다.

MySQL이 비정상 종료 되는 경우 InnoDB 데이터 파일은 두 종류의 일관되지 않은 데이터를 가집니다.

1. **커밋됐지만 데이터 파일에 기록되지 않은 데이터**
2. **롤백됐지만 데이터 파일에 이미 기록된 데이터**

`1번`의 경우 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하면 됩니다.

`2번`의 경우 변경되기 전의 내용을 가진 언두 로그의 내용을 데이터 파일에 복사합니다. 
이때 리두 로그는 커밋, 롤백, 트랜잭션 실행 중간 상태 여부 등과 같은 것을 확인할때 사용될 수 있습니다.

DBMS에서 **이상적**으로는 리두 로그는 트랜잭션이 커밋됐을때 즉시 디스크로 기록되는 상황입니다. 하지만 **현실적**으로 매번 디스크에 기록하는 상황은 많은 부하가 유발될 수 있기에 특정 주기로 리두 로그를 디스크에 동기화 할 지 결정하는 시스템 변수로 `innodb_flush_log_at_trx_commit`이 존재합니다.

```sql
# 1초에 한번씩 리두 로그를 디스크로 기록하고 동기화를 실행함
innodb_flush_log_at_trx_commit = 0

# 매번 트랜잭션이 커밋될 때마다 디스크로 기록하고 동기화까지 수행한다.
innodb_flush_log_at_trx_commit = 1

# 매번 트랜잭션이 커밋될때마다 디스크로 기록은 되지만 실질적인 동기화는 1초에 한번씩 실행됨
# 커밋되면 변경 내용이 운영체제의 메모리 버퍼로 기록되는것이 보장됨
innodb_flush_log_at_trx_commit = 2
```

<br><br>

### 4.2.12 어댑티브 해시 인덱스

사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스입니다. (시스템 변수를 통해 활성화 및 비활성화 가능)

어댑티브 해시 인덱스는 B-Tree의 검색 시간을 줄여주기 위해 도입된 기능입니다.

`해시 인덱스 = ‘인덱스 키 값’ + ‘데이터 페이지 주소’`

- `인덱스 키 값`: B-Tree 인덱스의 고유번호와 B-Tree 인덱스의 실제 키 값 조합으로 갱신됨
- `데이터 페이지 주소`: 실제 키 값이 저장된 데이터 페이지의 메모리 주소를 가지는데, 이는 InnoDB 버퍼 풀에 로딩된 페이지의 주소를 의미 합니다.

어댑티브 해시 인덱스는 **버퍼 풀에 올려진 데이터 페이지에 대해서만 관리**되고, 버퍼 풀에서 해당 데이터 페이지가 없어지면 어댑티브 해시 인덱스에서도 해당 페이지의 정보는 사라집니다.

<br>

**어댑티브 해시 인덱스가 성능 향상에 도움이 되지 않는 경우**

- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우 (조인, LIKE 패턴 검색)
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

<br>

**성능 향상에 도움이 되는 경우**

- 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(= 디스크 읽기가 많지 않은 경우)
- 동등 조건 검색(동등 비교 및 IN 연산자)이 많은 경우
- 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

<br>

**어댑티브 해시 인덱스 사용시 주의점**

- 성능 향상에 도움이 되는지 안되는지 판단 여부는 어렵습니다. 다만, 버퍼 풀에서 접근하는것을 더 빠르게 만드는 기능이므로 데이터 페이지를 디스크에서 읽어오는 경우가 많다면 성능 향상에 큰 도움이 되지 않습니다.
- 어댑티브 해시 인덱스 또한 큰 메모리 공간을 사용할 수 있습니다.
- 테이블의 삭제 작업에 많은 영향을 줍니다. 테이블 삭제 혹은 변경시 모든 데이터 페이지 내용을 어댑티브 해시 인덱스에서 제거하거나 변경해야 합니다. 이로 인해 많은 CPU 자원을 사용할 수 있습니다.

<br>

**어댑티브 해시 인덱스의 효율 계산**

```sql
SHOW ENGINE INNODB STATUS

-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 34679, node heap has 1 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
Hash table size 34679, node heap has 3 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
Hash table size 34679, node heap has 2 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
26.7 hash searches/s, 98.5 non-hash searches/s
```

초당 125.2번의 검색이 실행됐고, 어댑티브 해시 인덱스는 초당 26.7번 사용, 98.5번은 사용하지 못했습니다.
위에선 26.7 / (26.7 + 98.5) * 100 = 21% 정도밖에 어댑티브 해시 인덱스를 사용하지 못했습니다.

어댑티브 해시 인덱스의 사용량이 100%에 근접 할수록 효율이 높다고 할 수 있습니다.

<br><br><br>

## ✅ 4.4 MySQL 로그 파일

로그 파일을 이용하면 MySQL 서버의 깊은 내부 지식이 없어도 MySQL의 상태 및 부하를 일으키는 원인을 쉽게 찾아 해결할 수 있습니다.

<br><br>

### 4.4.1 에러 로그 파일

MySQL 설정 파일(my.cnf)에서 log_error라는 이름의 파라미터로 정의된 경로에
(설정이 없다면 datadir 파라미터에 설정된 디렉터리) `.err`이라는 확장자가 붙은 파일로 생성됨

에러 로그는 다음과 같은 종류가 있습니다. (자세한 내용은 `147~148page` 참조)

- MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지
- 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
- 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
- 비정상적으로 종료된 커넥션 메시지
- InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지
- MySQL의 종료 메시지

<br><br>

### 4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)

제너럴 쿼리 로그는 실행되기 전에 MySQL이 쿼리 요청을 받으면 바로 기록하기 때문에 쿼리 실행 중에 에러가 발생해도 일단 로그 파일에 기록됩니다.

로그 파일의 경로는 general_log_file 이라는 이름의 시스템 변수에 설정돼 있으며 파일이 아닌 테이블에 저장하도록 설정할 수 있습니다. (이때는 SQL로 조회, log_output 파라미터로 설정)

<br><br>

### 4.4.3 슬로우 쿼리 로그

MySQL 서버의 쿼리 튜닝은 두 가지로 나뉩니다.

1. **서비스가 적용되기 전에 전체적으로 튜닝 하는 경우**
2. **서비스 운영 중에 MySQL 서버의 전체적인 성능 저하를 검사하거나 정기적인 점검을 위한 튜닝인 경우**

2번의 경우 어떤 쿼리가 문제인지 알기 어려운데 슬로우 쿼리를 이용하면 많은 도움을 받을 수 있습니다.

슬로우 쿼리 로그 파일에는 long_query_time 시스템 변수에 설정한 시간 이상의 소요된 쿼리가 기록됩니다. 또한 반드시 정상적으로 쿼리가 실행된 경우만 기록될 수 있습니다.

`슬로우 쿼리에 로그가 남았다는 의미는 long_query_time보다 더 많은 시간이 걸린 쿼리`이므로 우리가 튜닝하려는 성능이 좋지 않은 쿼리를 선별하여 볼 수 있습니다.

슬로우 쿼리 역시 파일 혹은 테이블 기록을 선택할 수 있습니다.

슬로우 쿼리에 세부적인 내용, 통계, 쿼리별 실행 횟수 등에 대한 정보는 책 `151~153page`를 참조

<br><br><br><br>

# 📌 05 트랜잭션과 잠금

핵심: `잠금`, `트랜잭션`, `트랜잭션 격리 수준`

- 트랜잭션은 작업의 완전성(+ 데이터의 정합성)을 보장해 주는 것입니다. 완벽하게 처리하거나, 원 상태로 복구하거나 **둘 중 하나의 선택지**만 있습니다.
    
    따라서 작업의 일부만 적용되는 현상인 Partial update가 발생하지 않도록 하는 기능입니다.
    
- 잠금은 **동시성을 제어하기 위한 기능**입니다. 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 한 시점에 하나의 커넥션만 변경할 수 있게 해주는 역할을 합니다.
- 트랙잭션 격리 수준은 하나 혹은 여러 **트랜잭션 간의 작업 내용을 어떻게 공유하고 차단**할 것인지 결정하는 레벨을 의미 합니다.

<br><br><br>

## ✅ 5.1 트랜잭션


### 5.1.1 MySQL에서의 트랜잭션

트랜잭션은 하나의 논리적인 작업에 쿼리의 개수에 관계없이 논리적인 작업 셋이 100% 적용되거나(COMMIT을 했을때) 아무것도 적용되지 않아야 함(ROLLBACK)을 보장해주어야 합니다.

```sql
# MyISAM
mysql> create table tab_myisam (fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=MyISAM;
mysql> insert into tab_myisam (fdpk) values(3);

# INNODB
mysql> create table tab_innodb (fdpk int not null, primary key (fdpk)) engine=INNODB;
mysql> insert into tab_innodb(fdpk) values(3);

# MyISAM
mysql> insert into tab_myisam (fdpk) values (1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'tab_myisam.PRIMARY'

# INNODB
mysql> insert into tab_innodb (fdpk) values(1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'tab_innodb.PRIMARY'

mysql> select * from tab_myisam;
+------+
| fdpk |
+------+
|    1 |
|    2 |
|    3 |
+------+

mysql> select * from tab_innodb;
+------+
| fdpk |
+------+
|    3 |
+------+
```

두 insert 모두 PK 중복 오류로 쿼리가 실패했지만 트랜잭션을 사용하지 않는 MyISAM 테이블은 1, 2값이 INSERT 된 상태로 남아있습니다.

반면에 InnoDB는 쿼리 도중 오류가 발생했으므로 Rollback을해 1, 2값이 남아있지 않습니다.

<br><br>

### 5.1.2 주의사항

트랜잭션은 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋습니다. 즉 프로그램 코드에서 트랜잭션의 범위를 최소화 해야 합니다.

<br>

**포괄적인 트랜잭션 범위**

```sql
1) 처리 시작
	**-> 커넥션 생성
	-> 트랜잭션 시작**
2) 로그인 여부 확인
3) 글쓰기 오류 확인
4) 첨부로 업로드된 파일 저장
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일 발송
9) 알림 메일 발송 이력을 DBMS에 저장
10) 처리 완료
	**-> 트랜잭션 COMMIT
	-> 커넥션 반납**
```

- 2, 3, 4는 트랜잭션에 포함될 필요가 없습니다. → DB에 C, U, D하는 코드가 없음
- 8번 작업은 외부 API를 호출합니다. 만약 메일 서버와 통신할 수 없는 상황인 경우 DBMS 서버까지 위험해질 수 있습니다.
- 결국 5, 6과 9번 작업만이 트랜잭션이 필요합니다.

<br>

**최소한의 트랜잭션 범위**

```sql
1) 처리 시작
2) 로그인 여부 확인
3) 글쓰기 오류 확인
4) 첨부로 업로드된 파일 저장
	-> 커넥션 생성
	-> 트랜잭션A 시작
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
	-> 트랜잭션A COMMIT
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일 발송
	-> 트랜잭션B 시작
9) 알림 메일 발송 이력을 DBMS에 저장
	-> 트랜잭션B COMMIT
	-> 커넥션 반납
10) 처리 완료
```

결국 **프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화 해야하는것이 핵심이 됩니다.**

또한 외부 API를 호출하는 네트워크 작업이 있는경우는 반드시 트랜잭션에서 배제해야 합니다.

<br><br><br>

## ✅ 5.2 MySQL 엔진의 잠금

MySQL에서 사용되는 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나뉩니다.

MySQL 엔진 레벨의 잠금은 모든 스토리지에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않습니다.

<br><br>

### 5.2.1 글로벌 락

```sql
# 글로벌 락 획득 쿼리 MySQL 서버 전체에 영향을 미침
FLUSH TABLES WITH READ LOCK
```

- MySQL 에서 제공하는 잠금 가운데 가장 범위가 큽니다.
- SELECT를 제외한 대부분의 DDL 질의이나 DML 질의를 하는 경우 락이 해제될 때까지 해당 질의는 대기 상태가 됩니다.
- 해당 락은 잠금을 걸기전에 테이블을 플러시 해야 하므로 테이블에 실행중인 모든 종류의 쿼리가 완료돼야 합니다.

InnoDB 스토리지 엔진이 기본이 되었고 트랜잭션을 사용하므로 굳이 모든 데이터 변경 작업을 멈출 필요는 없습니다.

따라서 백업 툴들의 안정적인 실행을 위한 백업 락이 도입됐습니다.

```sql
LOCK INSTANCE FOR BACKUP;
# 백업 실행
UNLOCK INSTANCE;
```

특정 세션에서 백업 락을 획득하면 모든 세션에서 다음과 같이 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 됩니다.

- DB 및 테이블 등 모든 객체 생성, 및 변경, 삭제
- REPAIR TABLE, OPTIMZIE TABLE 명령
- 사용자 관리 및 비밀번호 변경

백업락은 일반적인 테이블의 데이터 변경은 허용합니다. 일반적인 MySQL 서버는 소스 서버, 레플리카 서버로 구성되는데 백업시 글로벌 락을 획득하면 많은 지연이 걸릴 수 밖에 없습니다.

- 글로벌 락이 진행되는 동안 서비스를 멈춰야 함
- 백업 중 DDL 명령이 들어왔을때 다시 백업을 해야 함

위와 같은 불편함을 보완하기 위해 백업 락이 도입됐습니다.

<br><br>

### 5.2.2 테이블 락

테이블 락은 개별 테이블 단위로 설정되는 잠금이며 명시적 혹은 묵시적으로 특정 테이블의 락을 얻을 수 있습니다.

```sql
# 명시적 락 -> 명시적으로 반납 할 수 있음(UNLOCK TABLES)
LOCK TABLES table_name [READ | WRITE]
```

- MyISAM, InnoDB 스토리지 엔진 모두 동일하게 사용할 수 있습니다.
- 묵시적인 테이블 락은 쿼리가 실행되는 동안 자동으로 획득했다가 쿼리가 완료된 후 자동 해제됩니다.
- 다만 InnoDB의 경우 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되진 않습니다. (DDL의 경우에만 잠금함)

<br><br>

### 5.2.3 네임드 락

- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정 합니다. (예시는 `교재 163page`)
- 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금입니다.
- 만약 데이터베이스 서버 1대에 5대의 웹 서버가 접속하여 서비스 하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화 하는 상황이거나, 혹은 배치 프로그램처럼 한번에 많은 레코드를 변경할때 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류하여 네임드 락을 걸고 쿼리를 실행하면 간단히 해결할 수 있습니다.

<br><br>

### 5.2.4 메타데이터 락

데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금입니다.

명시적으로 획득할 순 없고 `RENAME TABLE tab_a TO tab_b`와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금 입니다.

RENAME TABLE의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 설정하므로 바뀐 테이블의 이름때문에 이전 테이블의 이름을 찾지 못하는 오류같은 상황을 피할 수 있습니다.

(구체적인 예시는 `164~166page`)

<br><br><br>

## ✅ 5.3 InnoDB 스토리지 엔진 잠금

InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과 별개로 레코드 기반의 잠금 방식을 탑재하고 있습니다. 따라서 뛰어난 동시성 처리를 제공할 수 있습니다.

또한 InnoDB의 트랜잭션과 잠금, 그리고 잠금 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법도 도입되면서 잠금을 좀 더 명시적으로 관리할 수 있습니다.(찾아서 종료하거나 확인하거나 등)

<br><br>

### 5.3.1 InnoDB 스토리지 엔진의 잠금

레코드 기반의 잠금 기능을 제공하며 레코드 락, 갭 락, 넥스트 키 락 등 다양한 락을 제공합니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/81a47606-dd59-4ce8-ba97-500bd8e8fb6e)

<br>

**레코드 락**

- 레코드 자체만을 잠그는 락을 말합니다.
- 레코드 자체가 아니라 인덱스의 레코드를 잠급니다. 따라서 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정합니다.
- PK, Unique 인덱스에 의한 변경 작업에서는 레코드 자체에서만 락을 겁니다.

<br>

**갭 락**

- 갭 락은 레코드 자체가 아니라 레코드의 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미합니다.
- 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것입니다.

<br>

**넥스트 키 락**

- 레코드 락 + 갭 락을 합쳐 놓은 형태의 잠금을 말합니다.
- STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리수준을 사용해야 합니다.
- `innodb_locks_unsafe_for_binlog` 시스템 변수가 비활성화되면(0으로) 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸립니다.
- 락의 목적은 **레플리카 서버에서 실행될때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적**입니다.
- 다만 넥스트 키 락과 갭 락으로 데드락이 발생하는 경우가 많으므로 바이너리 로그 포맷을 ROW 형태로 바꿔 락을 줄이는것이 좋습니다. (`8.0부터는 ROW 포맷의 바이너리 로그가 기본 설정임`)

<br>

**자동 증가 락**

- AUTO_INCREMENT라는 칼럼 속성을 위한 락입니다.
- 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 합니다.
- 이를 위해 내부적으로 테이블 수준의 잠금인 **Auto Increment Lock**을 사용합니다. (**테이블에 하나만 존재**)
    - 다만 INSERT, REPLACE와 같은 새로운 레코드를 저장하는 쿼리에서만 필요하고 AUTO INCREMENT 값을 가져오는 **짧은 순간만 락이 걸리므로 크게 문제가 되지 않습니다.**
- inodb_autoinc_lock_mode라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경 가능
    - 0, 1, 2 설정 별 설명은 `169 ~ 170page 참조` (8.0의 기본값은 2임)
    
<br>

**인덱스와 잠금**

레코드 락은 인덱스를 잠그는 방식으로 처리 됩니다.

```sql
// first_name 칼럼만 ix_firstname이라는 인덱스가 있는 경우
SELECT COUNT(*) FROM employees WHERE first_name='Georgi';

253

SELECT COUNT(*) FROM employees WHERE first_name='Georgi' AND last_name='Klassen';

1

UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen';
```

위 결과에서 last_name 칼럼은 인덱스에 없기 때문에 first_name 인덱스로만 탐색을 하게 됩니다. 따라서 253건의 레코드가 모두 잠기게 됩니다.

결국 UPDATE를 위해 적절한 인덱스가 없다면 클라이언트 간 동시성이 떨어지며 성능이 저하될 수 있습니다.

**`MySQL의 InnoDB에선 인덱스 설계가 정말 중요합니다..!!`**

<br><br>

### 5.3.3 레코드 수준의 잠금 확인 및 해제

- 레코드 수준의 잠금은 테이블 수준의 잠금보다는 조금 더 복잡합니다.
- 테이블의 레코드 각각에 잠금이 걸리므로 해당 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아있어도 잘 발견되지 않습니다.
- MySQL 8.0부터는 performance_schema의 data_locks와 data_lock_waits 테이블로 잠금과 잠금 대기 순서를 확인할 수 있습니다.

잠금과 대기 순서는 `173~175page`를 참조

<br>

**IX 잠금**

`Intention Exclusive Lock (IX)` - 트랜잭션이 테이블의 개별 레코드에 베타 락 설정

테이블락과 레코드 락이 공존할 수 있도록 하는 락이며 테이블의 특정 레코드에 추후 락을 걸겠다는 의미를 가집니다.

<br><br><br>

## ✅ 5.4 MySQL의 격리 수준

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/a40cf287-b6ce-4fa9-9a8e-278ec5a46ce4)


- 트랜잭션 격리 수준이란 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것입니다.
- 위의 그림에서 위에서 아래로 갈수록 트랜잭션간 데이터 격리(고립) 정도가 높아지고 동시 처리 성능도 떨어집니다.
- SERIALIZABLE 정도의 수준이 아니라면 성능의 개선이나 저하는 미미한 수준입니다.

<br><br>

### 5.4.1 READ UNCOMMITTED

트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부 상관없이 다른 트랜잭션에서 보입니다.

READ UNCOMMITTED는 다음과 같은 문제가 있습니다.

1. **A 트랜잭션**에서 10번 사원의 나이를 27 → 28 변경
2. **B 트랜잭션**이 10번 사원의 나이를 읽음
    1. 28살 조회 (더티 리드 - 특정 트랜잭션 처리 작업이 완료되지 않아도 볼 수 있는 현상)
3. **A 트랜잭션**에서 10번 사원의 나이를 롤백을 함 28 → 27
4. **B 트랜잭션**은 여전히 10번 사원의 나이를 28살로 보고 로직 진행

RDBMS 표준은 READ UNCOMMITTED를 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많습니다.

<br><br>

### 5.4.2 READ COMMITTED

오라클 DBMS에서 기본으로 사용되는 격리 수준이며, 온라인 서비스에서 가장 많이 선택되는 격리 수준입니다.

어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있습니다.

다만 여전히 REPEATABLE READ가 지켜지지 않는 부정합의 문제가 있습니다.

1. 10번 사원의 이름은 LaLa임
2. **B 트랜잭션**이 사원 이름이 RaRa인걸 조회함
    1. 데이터 조회되지 않음
3. **A 트랜잭션**에서 10번 사원의 이름을 RaRa로 변경 및 커밋함
4. **B 트랜잭션**은 사원 이름이 RaRa인걸 조회함
    1. 10번 사원이 조회됨

위 예시는 하나의 트랜잭션 내부에서 똑같은 SELECT 쿼리를 실행했을때 항상 같은 결과를 가져와야 하는 REPEATABLE READ 정합성에 어긋나는 결과입니다.

금액의 총 합을 계산하는 SELECT 쿼리가 실행될 때마다 다른 결과를 가져오게 되는 금전적인 처리와 연결된 경우 큰 문제가 발생할 수 있습니다.

**격리 수준에 의해 실행하는 SQL 문장이 가져오는 결과를 정확히 예측할 수 있어야 합니다.**

<br><br>

### 5.4.3 REPEATABLE READ

REPEATABLE READ는 MySQL의 InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준 입니다.

`바이너리 로그를 가진 MySQL 서버에선 최소 REPEATABLE READ 격리 수준 이상을 사용해야 합니다.`

→ 바이너리 로그의 경우 데이터 복구, 백업, 복제 등과 같은 용도로 활용되는데 이런 목적으로 사용되는 경우 특히 데이터의 일관성과 격리 수준이 중요해지기 때문

InnoDB의 트랜잭션은 고유한 트랜잭션 번호(순차증가하는)를 가지며 언두 영역에 백업된 모든 레코드엔 변경을 발생시킨 트랜잭션 번호가 같이 기록됩니다.

MVCC를 보장하기 위해 실행중인 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞서는 언두 영역의 데이터는 삭제할 수 없습니다.

→ 즉, 자신 보다 번호가 낮은 트랜잭션이 처리한(커밋) 결과만 볼 수 있다는 의미가 됩니다.

예를들어 다음과 같은 상황이 있습니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/da016557-afb6-4503-8ef7-0c45abfb023c)
출처: https://mangkyu.tistory.com/299

- 사용자 A에 의해 id값이 50인 사용자의 이름을 `MangKyu → MinKyu`변경해도
- 사용자 B가 id ≥ 50 조건으로 조회했을때는 여전히 MangKyu라는 이름으로 조회됩니다.
    - **그 이유는 사용자 A는 트랜잭션 번호가 12이고, B는 10이므로 B 입장에선 SELECT를 하면 자신보다 작은 트랜잭션 번호에서 변경한 것만 보게 되기 때문입니다.**

다만 위 상황에서 하나의 레코드에 대한 백업 데이터가 얼마든지 많아질 수 있습니다. 따라서 트랜잭션을 장시간 종료하지 않는다면 언두 영역이 백업 데이터로 무한정 커질수도 있습니다. → MySQL 성능 저하의 원인

다만 REPEATABLE READ 격리 수준에서도 다음과 같은 부정합이 발생할 수 있습니다.

![image](https://github.com/Invincible-Backend-Study/Real-MySQL/assets/66772624/85186729-7d00-4f82-b7f9-a34b31bef791)
출처: https://mangkyu.tistory.com/299

- T-ID=10: `SELECT FOR UPDATE` 구문으로 배타 락을 검(id 50 레코드 쓰기 잠금)
    - id값이 50 이상인 조건에서 MangKyu 한명만 조회됨
- T-ID=12: id값이 51인 새로운 멤버를 삽입함
- T-ID=10: 다시 SELECT FOR UPDATE 구문으로 id값이 50 이상인 조건으로 검색
    - 이때 T-ID=12에서 추가된 새로운 사용자 Martin도 조회되게 됩니다.

이렇게 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보이거나 보이지 않는 현상을 PHANTOM READ라고 합니다.

FOR UPDATE의 경우 배타적 잠금을 걸지만 언두 로그에는 잠금을 걸 수 없으므로 SELECT 하는 레코드에 직접 쓰기 잠금을 걸게 됩니다.

따라서 SELECT … FOR UPDATE, SELECT … LOCK IN SHARAE MODE로 조회되는 레코드는 언두 영역의 변경 전 데이터가 아니라 **현재 레코드의 값을 가져오게 됩니다.**

→ InnoDB 스토리지 엔진에선 갭 락과 넥스트 키 락 덕분에 PHANTOM READ 현상이 발생하지 않습니다.

<br><br>

### 5.4.4 SERIALIZABLE

가장 단순한 격리 수준이며 동시에 가장 엄격한 격리 수준 입니다. 다만 너무 엄격하여 동시 처리 성능도 다른 격리 수준보다 떨어집니다.

이 격리 수준은 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야 하며 동시에 다른 트랜잭션은 해당 레코드를 절대 변경할 수 없습니다.

즉 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없습니다.
